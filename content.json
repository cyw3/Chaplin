{"posts":[{"title":"Welcome to yalechen&#39;s blog","text":"This is the blog I first posted.I will make the blog more open and share something interesting sometime.I hope I can record my life by this way.AndHappy New Year.God bless you.","link":"/2022/07/24/2016-01-12-Welcome-to-yalesonchan-blog/"},{"title":"申万行业分类日间表格","text":"前言申银万国证券股份有限公司（简称：申银万国），是国内最早的一家股份制证券公司，也是目前国内规模最大、经营业务最齐全、营业网点分布最广泛的综合类证券公司之一。为能够实时掌握申银万国各行业的股市数据，包括当天收盘价、成交量、涨跌幅等，以应对变化多端的市场，采取正确的举措，收获最大的利益，所以一个能够实时生成申万行业分类日间表格是十分需要的。接下来，我们便使用况客Api实现这个的表格。 目录1、申万行业分类日间表格的介绍 2、使用况客API实现的具体思路 1.申万行业分类日间表格的介绍在开始动手之前，我们先看看我们要制作的成品是什么样子的吧。如下图： 上图，是搜索的申万行业一级行业中各个个股当天的基本数据，包括了当天收盘价、成交量、涨跌幅、周涨跌幅、月涨跌幅、年涨跌幅等等。（注：此处搜索的申万行业一级行业是“商业贸易”，即SW1 &lt;- ‘商业贸易’）当然，你也可以根据需要选定表格的内容。 从表格，我们可以了解到我们关注的个股的情况，看他目前是张还是跌，涨跌幅多大，通过比较周涨跌幅、月涨跌幅、年涨跌幅来判断该个股是否值得投资，以更好的做出正确的判断、举措。 2.使用况客API实现表格的具体思路1、系统环境 123win7RStudioqutke 需要提前下载况客R语言Api，即qutke，GitHub链接是：https://github.com/qutke/qutke可以安装注册git，通过git命令来下载相应的R包。 1git clone https://github.com/qutke/qutke.git 也可以通过RStudio命令来下载： 12library(devtools)install_github('qutke/qutke') 2、咱们需要初始化，为正式编写代码做个准备吧，就像木匠一样，先把原材料以及工具准备好，才干活是不。其中，我们需要安装需要使用的R包，这里我们要用得到的有与date日期相关的lubridate包，以及我们刚下载的qutke。接着，通过数据库key，我们进行初始化，并与数据库连接上。 12345#安装相应的需要使用的R包library('lubridate')library(qutke)key&lt;-'ff5ed58edf645c6581e8148db1130dc310fbab5fdccc4b2a9ea0be30f4128ace'init(key) 3、定义变量，取得需要的参数 1234567891011121314151617date &lt;- Sys.Date()#获取交易日期，虽然在init(key)函数里面就已经取得了tradingDay，并且保存在e$TRADINGDAY变量中。#不过这里为了介绍getDate()函数。于是就写明了吧。lastYearDate &lt;- as.Date(paste(year(date)-1,month(date),day(date),sep='-'))tradingDay &lt;- getDate(data='tradingDay',startdate=lastYearDate,enddate=date,key=key)length &lt;- length(tradingDay)date &lt;- tradingDay[length]#进行筛选,判断其SW1,此时只对‘商业贸易’这一行业进行筛选sw1 &lt;- '商业贸易'#通过getIndustry()函数，取得SW1，即‘商业贸易’这一行业相对应的个股industry &lt;- getIndustry(data='industryType',date=date,SW1=sw1,key=key)#符合条件的个股的股票代码qtid &lt;- industry$qtid#获得今年的第一个交易日日期FirstDay &lt;- as.Date(paste(year(date)-1,'1','1',sep='-'))FirstDay &lt;- (getDate(data='tradingDay',startdate=FirstDay,enddate=date,key=key))[1] 4、依照股票代码qtid来筛选获取数据库中这些个股的数据，并进行计算。此处，我们可以直接获得当天的收盘价、成交量，但是涨跌幅是需要进行计算的。涨跌幅的计算公式是：(当前最新成交价（或收盘价）-开盘参考价)÷开盘参考价×100%一般情况： 开盘参考价=前一交易日收盘价除权息日： 开盘参考价=除权后的参考价我们参考以上涨跌幅的计算公式，可以计算当天的涨跌幅，至于周涨跌幅，则是要把开盘参考价改为5个交易日前的收盘价即可，至于月涨跌幅、年涨跌幅、年初至今涨跌幅，亦是一个道理。 12345678910111213141516171819202122232425262728#选用不复权#通过getDailyQuote()方法获取股票日间行情。mktDaily &lt;- getDailyQuote(data='mktDaily',qtid = qtid,startdate=date,enddate=date,key=key)qtid &lt;- mktDaily$qtid#个股证券名称SecuAbbr &lt;- (getIndustry(data='industryType',qtid = qtid,date=date,SW1=sw1,key=key))$SecuAbbr#当日收盘价close&lt;- mktDaily$close#当日交易量volume &lt;- mktDaily$volume#上一交易日的收盘价prevClose &lt;- mktDaily$prevClose#当日涨跌幅quoteChangeDaily &lt;- (close-prevClose)/prevClose#获取近期的数据，分别为近一周、近一月、近一年、年初mktWeek &lt;- getDailyQuote(data='mktDaily',qtid = qtid,startdate=tradingDay[length-5],enddate=tradingDay[length-5],key=key)mktMonth &lt;- getDailyQuote(data='mktDaily',qtid = qtid,startdate=tradingDay[length-20],enddate=tradingDay[length-20],key=key)mktYear &lt;- getDailyQuote(data='mktDaily',qtid = qtid,startdate=tradingDay[1],enddate=tradingDay[1],key=key)mktFYear &lt;- getDailyQuote(data='mktDaily',qtid = qtid,startdate=FirstDay,enddate=FirstDay,key=key)#通过公式计算涨跌幅#近一周的涨跌幅quoteChangeWeek &lt;- (close-mktWeek$close)/mktWeek$close#近一月的涨跌幅quoteChangeMonth &lt;- (close-mktMonth$close)/mktMonth$close#近一年的涨跌幅quoteChangeYear &lt;- (close-mktYear$close)/mktYear$close#年初至今的涨跌幅quoteChangeFYear &lt;- (close-mktFYear$close)/mktFYear$close 5、生成表格data.frame 12345678stock1 &lt;- data.frame('1'=qtid,'2'=SecuAbbr,'3'=paste(year(date),month(date),day(date),sep='-'),'4'=close, '5'=quoteChangeDaily,'6'=volume,'7'=quoteChangeWeek, '8'=quoteChangeMonth,'9'=quoteChangeYear, '10'=quoteChangeFYear,'11'=sw1)#修改data.frame的列名names(stock1)&lt;-c('代码','名称','日期','收盘价','涨跌幅(%)','成交量(万元)','周涨跌幅(%)','月涨跌幅(%)','年涨跌幅(%)','年初至今涨跌幅（%）','SW1')#发送到况客的数据服务器中，服务器将保存你生成的dataframe，并可以在况客投研平台看到可视化界面postData(stock1,name='stock1',key=key) 6、登录况客投研平台，在 创建图表 选项中对生成的图表进行修改，并增加涨跌提示、搜索、排序等功能，然后可以将表格嵌入网站、博客之中，进行展示。","link":"/2022/07/24/2016-01-13-Classification-Form/"},{"title":"投资组合的收益率走势图","text":"前言各位看官好，我是小陈，今天又来献丑了。作为金融小白，小陈我最近一直在恶补投资方面的知识。而前些天，正好涌哥叫我用况客API实现一个投资组合的收益率走势图，感觉自己一身代码神功又有用武之地了。 所谓投资组合是说，投资持有各种金融产品的组合，需要分段分批分散投入，目的是分散风险。当然，投资人都是希望自己投的股票能够不断的涨，把钱花在刀刃上，以最少的钱套取最大的利益，但是这是不现实的，毕竟股市，尤其是中国股市（大家都懂的），是变化莫测的。所以，如何尽可能的减少风险，利益最大化，成为了关键所在。而接下来我将说到的“收益率走势图”，将会是一个不错的工具，让我们趋利避害。 目录1.投资组合以及收益率走势图的介绍 2.收益率走势图效果图展示 3.收益率走势图的代码实现以及优化 1.投资组合以及收益率走势图的介绍美国经济学家马考维茨(Markowitz)曾这样说过：“若干种证券组成的投资组合，其收益是这些证券收益的加权平均数，但是其风险不是这些证券风险的加权平均风险，投资组合能降低非系统性风险。” 马考维茨最著名的作品便是《投资组合理论》，他还因此获得了诺贝尔经济学奖。当然，本文的重点不是说要探讨马考维茨的“投资组合理论”云云（其实我也不懂）。但是这也足够说明了，合理的投资组合，能够让投资者获取更大的利益。投资者持有多种金融产品，不同的产品可能具有不同的市场地位和价值优势，需要综合评价企业的价值能力，进行投资组合分析。至于收益率走势图，显然是我们进行投资组合分析时的一大工具了。 收益率是指投资的回报率，一般以年度百分比表达，根据当时市场价格、面值、息票利率以及距离到期日时间计算。对公司而言，收益率指净利润占使用的平均资本的百分比。而通过收益率走势图，我们可以实时地知道，我们所持股票的自买入以来的收益情况，以及可以大体预测股票的大致走向，如果辅以好的算法的话，甚至可以如同化身“预言家”，对未来股票走势了如指掌。 2.收益率走势图效果图展示哎呀，我也不说什么太虚的了。直接开干。以下便是我们代码实现的效果图了。怎么样？很棒吧！觉得羡慕吧！羡慕就继续往下看，走起。yieldChart 3.收益率走势图的代码实现以及优化1.系统环境 跟上一篇文一样，我们需要准备好开发所需要的环境。就像学习一样，得要有个好的学习氛围嘛。 123win7系统RStudio编辑器qutke包 需要提前下载况客R语言Api，即qutke，GitHub链接可以安装注册git，通过git命令来下载相应的R包。 1git clone https://github.com/qutke/qutke.git 也可以通过RStudio命令来下载： 12library(devtools)install_github('qutke/qutke') 2.初始化，弹药准备 12345#安装相应的需要使用的R包library('lubridate')library(qutke)key&lt;-'ff5ed58edf645c6581e8148db1130dc310fbab5fdccc4b2a9ea0be30f4128ace'init(key) 3.参数选定 在制作走势图之前，我们得知道，是什么样的组合，什么时候买入的。这里，我参考了雪球里的一个热门组合“丁丁丁涨不停ZH078564”，分别是科大讯飞“002230.SZ”，以及登云股份“002715.SZ”。日期就选在“2015-10-01”吧。 12qtid &lt;- c('002230.SZ','002715.SZ')date &lt;- '2015-10-01' 4.获取股票基本信息 依次获取这两支股票的从买入日期至今的每天的收盘价。 123456789#股票基本信息md &lt;- getMD(data='keyMap',qtid=qtid,key=key)#股票日间行情(前复权)dailyQuote &lt;- getDailyQuote(data='mktFwdDaily',qtid=qtid,startdate=date,enddate=Sys.Date(),key=key)#当日收盘价(前复权)stock1 &lt;-dailyQuote[which(dailyQuote$qtid==qtid[1]),]stock2 &lt;-dailyQuote[which(dailyQuote$qtid==qtid[2]),]#x轴，作为时间轴。取买入日期至今。tradingDay &lt;- getDate(data='tradingDay',startdate=stock1$date[1],enddate=Sys.Date(),key=key) 5.数据处理，以备后面生成dataframe表格。此时，fwdAdjClose是每只股票在每一个交易日的收盘价。 1234567891011121314#归一化i &lt;- 1length &lt;- length(tradingDay)fwdAdjClose1 &lt;- c()fwdAdjClose2 &lt;- c()while(i&lt;=length){ fwdAdjClose1 &lt;- c(fwdAdjClose1,stock1[i,]$fwdAdjClose) if(is.null(fwdAdjClose1[i])||is.na(fwdAdjClose1[i])) fwdAdjClose1[i] &lt;- fwdAdjClose1[i-1] fwdAdjClose2 &lt;- c(fwdAdjClose2,stock2[i,]$fwdAdjClose) if(is.null(fwdAdjClose2[i])||is.na(fwdAdjClose2[i])) fwdAdjClose2[i] &lt;- fwdAdjClose2[i-1] i=i+1} 6.收益率计算 收益率计算公式是： 某只股票收益率 = （当天的股价-买入价）/ 买入价 *100 123#计算fwdAdjClose1 &lt;- (fwdAdjClose1-fwdAdjClose1[1])/fwdAdjClose1[1]*100fwdAdjClose2 &lt;- (fwdAdjClose2-fwdAdjClose2[1])/fwdAdjClose2[1]*100 7.生成dataframe表格，并将数据发送到况客投研中心，以便后期处理 1234#形成dataframeyieldChart &lt;- data.frame('date'=tradingDay,'2'=fwdAdjClose1,'3'=fwdAdjClose2)names(yieldChart)&lt;-c('日期',md[1,]$ChiAbbr,md[2,]$ChiAbbr)postData(yieldChart,name='yieldChart',key=key) 8.代码优化 当然，我们不能就这满足了。我们需要在对代码略微修改，使之只需要我们输入交易日期、股票组合，就可以自动生成需要的收益率走势图。 123456789101112131415161718192021222324252627282930313233343536373839404142getYieldChart&lt;-function(date,qtid=c(),key){ if(length(qtid)&lt;=0){ stop(&quot;Qtid is more than one.&quot;) } #股票基本信息 md &lt;- getMD(data='keyMap',qtid=qtid,key=key) #股票日间行情(前复权) dailyQuote &lt;- getDailyQuote(data='mktFwdDaily',qtid=qtid,startdate=date,enddate=Sys.Date(),key=key) #当日收盘价(前复权) stock &lt;- list() qtidlength &lt;- length(qtid) i &lt;- 1 while(i&lt;=qtidlength){ ChiAbbr &lt;- md[i,]$ChiAbbr qtidSt &lt;- md[i,]$qtid stock[[ChiAbbr]] &lt;- dailyQuote[which(dailyQuote$qtid==qtidSt),] i &lt;- i+1 } #x轴，作为时间轴。取买入日期至今。 tradingDay &lt;- getDate(data='tradingDay',startdate=stock[[1]]$date[1],enddate=Sys.Date(),key=key) fwdAdjClose &lt;- list() fwdAdjClose[['date']] &lt;- tradingDay #归一化 i &lt;- 1 length &lt;- length(tradingDay) while(i&lt;=qtidlength){ ChiAbbr &lt;- md[i,]$ChiAbbr j &lt;- 1 while(j&lt;=length){ fwdAdjClose[[ChiAbbr]] &lt;- c(fwdAdjClose[[ChiAbbr]],stock[[ChiAbbr]][j,]$fwdAdjClose) if(is.null(fwdAdjClose[[ChiAbbr]][j])||is.na(fwdAdjClose[[ChiAbbr]][j])) fwdAdjClose[[ChiAbbr]][j] &lt;- fwdAdjClose[[ChiAbbr]][j-1] j &lt;- j+1 } #计算 fwdAdjClose[[ChiAbbr]] &lt;- (fwdAdjClose[[ChiAbbr]]-fwdAdjClose[[ChiAbbr]][1])/fwdAdjClose[[ChiAbbr]][1]*100 i=i+1 } #形成dataframe yieldChart &lt;-data.frame(fwdAdjClose) postData(yieldChart,name='yieldChart',key=key)} 这样，就算完成了。（满意脸）","link":"/2022/07/24/2016-01-13-Portfolio-yield-Chart/"},{"title":"yalechen&#39;s Resume","text":"陳越威 联系方式 手机：18175139250 Email：yueshiyijie@gmail.com 微信号：cyw20130609 个人信息 陳越威/男/1994 本科/中南大学信息学院 技术博客：http://cyw3.github.io/yalechen Github: http://github.com/cyw3 期望职位：数据分析实习生 项目经历湘雅生物大数据项目使用中南大学湘雅医学院内部数据集，分析处理各有机物质的性质特征。我在此项目负责了java蛋白质分子解析平台的工作，在数据分析这一块成长快。 “找事er”App创业项目我在此项目负责了Android App开发工作，在Android与ThinkPHP后台的数据收发这一块做得出色。这个项目中，我最自豪的技术细节是，我能够连续7天每日每夜的进行开发工作，为的只是想要让我们的产品尽快的落地。 OriStone语言开发项目这是我自己想要做的项目。然后确定开始做这个项目之后，我每天泡在图书馆里面，利用图书馆的资源，在图书馆里面完成了OriStone编程语言的开发。一个属于自己的语言。在这个项目中，我遇到的最大的困难是，如何构建VM。本来是想要把OriSone架构在LLVM框架之上，以此降低开发难度。但是，为了学习其中的原理，我就自己写了个VM。 RoboCup移动智能机器人大赛这个系统是仿真地震过后，城市里面医疗、警察、火警，尽最大可能拯救市民，救火，以得到最大分数的比赛。主要是编写各智能体的运作算法。我负责的是其中医疗智能体的控制算法。对其使用了KNN算法进行分区，A* 算法进行路径搜寻等等。在2015年7月份带领团队在RoboCup世界杯取得世界第六的好成绩，又于10月份取得全国第三名的成绩。 CCV项目基于OpenCV框架，完成的银行卡号识别项目。这是我单独完成的项目。其中的难处在于数字的提取策略。后来我使用的基于灰度变化的数字提取方法：数字与数字的间隔往往是背景颜色或者是背景像素点个数和的一个波峰，即前景像素点个数和的一个波谷，我们利用这样的特点来分割图片。 开源项目和作品开源项目 OriStone语言 : 自创的一种类python编程语言。 CCV : OpenCV实例。 技术文章 投资组合的收益率走势图 MACD策略 技能清单以下均为我熟练使用的技能 语言：java/R/Python Web框架：ThinkPHP/Spring/Struct/Hebernate 数据库相关：MySQL/Hbase 版本管理、文档和自动化部署工具：Svn/Git 常用OS：Linux/Windows 算法：机器学习/算法导论 云计算：hadoop/Spark 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/2022/07/24/2016-01-13-Resume/"},{"title":"MACD策略","text":"前言各位看官好，我是小陈。前两篇文章，我们一起写了个数据表格和走势图，恩，是不是很容易啊，有没有信心满满现在！那么，接下来，我们来个有点难度的。咱们一起写一下MACD股票策略吧。 移动平均线(MA)是股市中最常用的一种技术分析方法，用来在大行情的波动段找到有效的交易信号。移动平均线不仅简单，而且有效，对股市操作具有神奇的指导作用，能有效地打败大部分的主观策略，是炒股、炒期货的必备基本工具。 接下来，我们仔细研究一下MACD策略的简单而又神奇之处吧。 目录1.MACD的介绍2.均线模型展示3.R语言实现MACD策略 1、MACD的介绍在介绍MACD之前，我们来介绍一下MA，也就是移动平均线。移动平均线(MA,Moving average）是以道·琼斯的”平均成本概念”为理论基础，采用统计学中”移动平均”的原理，将一段时期内的股票价格平均值连成曲线，用来显示股价的历史波动情况，进而反映股价指数未来发展趋势的技术分析方法。它是道氏理论的形象化表述。移动平均线的计算方法就是求连续若干天的收盘价的算术平均。天数就是MA的参数。 计算公式： MA = (C1+C2+C3+C4+C5+….+Cn)/n ,C为收盘价，n为移动平均周期数。例如，5日移动平均价格计算方法为： 1MA5 = （前四天收盘价+前三天收盘价+前天收盘价+昨天收盘价+今天收盘价）/5 移动平均线依时间长短可分为三种，即短期移动平均线，中期移动平均线，长期移动平均线。短期移动平均线一般以5日或10日为计算期间，中期移动平均线大多以30日、60日为计算期间；长期移动平均线大多以100天和200天为计算期间。有根据处理数据的方式的不同，移动平均线又分为简单移动平均线(SMA)、加权移动平均线(WMA)，以及指数平滑移动平均线(EMA)。 而今天我们说的，MACD(Moving Average Convergence / Divergence)也是基于移动平均线发展而来。 MACD称为指数平滑移动平均线，是从双指数移动平均线发展而来的，由快的指数移动平均线（EMA）减去慢的指数移动平均线，MACD的意义和双移动平均线基本相同，但阅读起来更方便。当MACD从负数转向正数，是买的信号。当MACD从正数转向负数，是卖的信号。当MACD以大角度变化，表示快的移动平均线和慢的移动平均线的差距非常迅速的拉开，代表了一个市场大趋势的转变。 2、均线模型展示这里，为了让大家能够跟更好的理解，我特地制作一下走势图。 这是以IBM2010年1月到2012年1月的股价走势。其中黑线代表的是K线（该公司每天的股价），蓝线代表的是ma5（该公司每5天收盘价的均值连成的曲线），以及绿线ma20（该公司每20天收盘价的均值连成的曲线）。可以看到，ma20被无数个红点以及紫点覆盖掉了。红点是表示此时ma5&gt;ma20，紫点是ma5&lt;ma20. 从图中，我们可以直观的看到，红线总是在上升，而紫线则总是在下降。自然而然地，大家就会想到，我们应该在红线的第一个点买入，在紫线的第一个点卖出，这样，我们就可以挣得更多钱了。 当然也不是说，使用了MACD策略，我们就一定赚钱，坐着收钱了。毕竟股市可不是这样简单的东西。但是MACD策略却可以让我们更加清晰的看到市场的本质，提高了胜率。不过，即便是有输有赢，我们也要找到胜率最高的那一只股票是不。以下这幅图便是我们今天的任务了。使用我们今天学到的MACD策略，并对这么一组股票进行模拟交易，然后按照收益率高低进行排序。第一行是沪深300指数，以作比较。 3、R语言实现MACD策略1）初始化 12345678library(quantmod)library(plyr)library(TTR)library(scales)library(ggplot2)library(qutke)key &lt;- 'faca4c8ff4dc1502d87944ea9cfd74f19918f0aef37fde6746b61d4d339bfcf3'init(key) 2）选定参数 123456sDate&lt;-as.Date(&quot;2015-1-1&quot;) #开始日期eDate&lt;-Sys.Date() #结束日期tradingDay &lt;- getDate(data='tradingDay',startdate=sDate,enddate=eDate,key=key)length &lt;- length(tradingDay)sDate &lt;- tradingDay[1]eDate &lt;- tradingDay[length] 可以通过getIndudtry方法获取况客的股票代码。不过因为有点多，所以我这里只选其中的20多支股票的股票代码。 12345# industry &lt;- getIndustry(data='industryType',date=eDate,key=key)# qtid &lt;- industry$qtidqtid &lt;- c('002230.SZ','002715.SZ',&quot;603789.SH&quot;, &quot;603799.SH&quot;, &quot;603806.SH&quot;, &quot;603808.SH&quot;, &quot;603818.SH&quot;,&quot;603828.SH&quot;, &quot;603869.SH&quot;, &quot;603883.SH&quot;, &quot;603885.SH&quot;, &quot;603889.SH&quot;, &quot;603898.SH&quot;, &quot;603899.SH&quot;, &quot;603901.SH&quot;, &quot;603918.SH&quot;, &quot;603939.SH&quot;, &quot;603968.SH&quot;, &quot;603969.SH&quot;, &quot;603988.SH&quot; ,&quot;603989.SH&quot;, &quot;603993.SH&quot;, &quot;603997.SH&quot;, &quot;603998.SH&quot;) 3）获取每支股票的数据，包括每个交易日的收盘价、ma5、ma20. 1234dailyQuote &lt;- getDailyQuote(data='mktFwdDaily',qtid=qtid,startdate=sDate,enddate=eDate,key=key)ldata &lt;- dailyQuote[,grep(&quot;qtid|date|close|ma5|ma20&quot;, names(dailyQuote)) ]#为true时候，补全ldata中是na的数值，以最近日期的数据 进行赋值 ldata&lt;-na.locf(ldata, fromLast=TRUE) 因为这次涉及到的数据处理比较多，听起来也比较虚，所以，我们在写代码的时候，可以多查看一下所得到的变量的数据结构是什么样子的。 123456789101112131415161718192021222324&gt; head(dailyQuote) qtid date close volume value fwdAdj fwdAdjOpen fwdAdjHi fwdAdjLo fwdAdjClose ret logRet1 000001.SZ 2015-01-05 16.02 286043643 4565387846 0.7574074 12.11094 12.33059 11.81556 12.13367 0.011364 0.0113002 000001.SZ 2015-01-06 15.78 216642140 3453446168 0.7574074 12.00491 12.41391 11.77769 11.95189 -0.014981 -0.0150953 000001.SZ 2015-01-07 15.48 170012067 2634796409 0.7574074 11.78526 11.98976 11.58833 11.72467 -0.019011 -0.0191944 000001.SZ 2015-01-08 14.96 140771421 2128003432 0.7574074 11.73981 11.79283 11.28537 11.33081 -0.033592 -0.0341695 000001.SZ 2015-01-09 15.08 250850023 3835378100 0.7574074 11.28537 12.02006 11.14146 11.42170 0.008021 0.0079896 000001.SZ 2015-01-12 14.77 155329086 2293104602 0.7574074 11.26265 11.39898 10.98241 11.18691 -0.020557 -0.020771 vwap vol30 ma5 ma10 ma20 ma601 15.9605 8427448605 11.72 11.45 11.17 9.232 15.9408 8529417547 11.82 11.51 11.22 9.303 15.4977 8476692763 11.91 11.52 11.23 9.374 15.1167 8460683917 11.83 11.54 11.27 9.435 15.2895 8493042075 11.71 11.62 11.31 9.496 14.7629 8437985489 11.52 11.62 11.34 9.55&gt; head(ldata) qtid date close ma5 ma201 002230.SZ 2015-01-05 27.40 17.11 18.172 002230.SZ 2015-01-06 27.72 16.99 18.123 002230.SZ 2015-01-07 27.20 16.95 18.084 002230.SZ 2015-01-08 27.20 17.07 18.045 002230.SZ 2015-01-09 27.10 17.13 17.976 002230.SZ 2015-01-12 27.91 17.19 17.93 4）以UP、Down标定。 对每只股票，以其每个交易日的ma20与ma5进行比较，当ma5&gt;ma20时候，取UP，当ma5&lt;ma20时候，取Down。然后，对数据以qtid为准进行分离并依照日期排序。 1234567891011121314151617181920212223242526272829303132# 散点数据genPoint&lt;-function(arg=c(),ldata){ if(length(arg)&gt;2){ stop('The length of args is two.') } if(length(arg)&lt;2){ arg &lt;- c(arg,2) } #[,c(1,arg[1])] pdata &lt;- ldata[which(ldata[,arg[2]]&gt;ldata[,arg[1]]),] pdata &lt;- cbind(pdata,'op'=c('Down')) #添加op列 xdata &lt;- ldata[which(ldata[,arg[2]]&lt;=ldata[,arg[1]]),] xdata &lt;- cbind(xdata,'op'='UP') return(rbind(pdata,xdata))} #以qtid分离数据，并返回一个listseparateQtid&lt;-function(pdata,qtid){ if(length(qtid)&lt;=0){ stop('The length of qtid is at least one.') } xdata &lt;- list() for(id in qtid){ xdata[[id]] &lt;- pdata[which(pdata$qtid==id),] } return(xdata)}pdata&lt;-genPoint(c(5,4),ldata)pdata &lt;- separateQtid(pdata,qtid)#以date数据进行排序for(id in qtid){ pdata[[id]] &lt;- pdata[[id]][order(pdata[[id]]$date,decreasing=F),]} 这个时候pdata是一个list类型的结构，所以我只列出其中一个元素的前几行数据以展示。 12345678&gt; head(pdata[[1]]) qtid date close ma5 ma20 op1 002230.SZ 2014-01-02 48.07 17.36 17.28 Down2 002230.SZ 2014-01-03 47.05 17.41 17.29 Down3 002230.SZ 2014-01-06 45.12 17.27 17.29 UP4 002230.SZ 2014-01-07 45.08 17.12 17.27 UP5 002230.SZ 2014-01-08 45.44 16.95 17.24 UP6 002230.SZ 2014-01-09 45.42 16.75 17.18 UP 5）选择交易点。 也就是上面的走势图所说的，在红线的第一点买入，在紫线的第一点卖出。模型设计思路： 以5日均线和20日均线的交叉，进行交易信号的判断。 当5日均线上穿20日均线则买入(红色)，下穿20日均线卖出(蓝色)。 1234567891011121314151617181920212223Signal&lt;-function(ldata=c(),pdata,qtid){ if(length(qtid)&lt;=0){ stop('The length of qtid is at least one.') } op1 &lt;- list() for(id in qtid){ pdata[[id]] &lt;- pdata[[id]][order(pdata[[id]]$date,decreasing=F),] op &lt;- pdata[[id]][1,] tmp &lt;- op$op i &lt;- 2 nrow &lt;- nrow(pdata[[id]]) while(i&lt;=nrow){ if(tmp!=pdata[[id]][i,]$op){ op &lt;- rbind(op,pdata[[id]][i,]) } tmp &lt;- pdata[[id]][i,]$op i=i+1 } op1[[id]] &lt;- op } return(op1)}tdata&lt;-Signal(ldata,pdata,qtid) 同pdata一样，这也是只展示了tdata的部分。 12345678&gt; head(tdata[[1]]) qtid date close ma5 ma20 op1 002230.SZ 2014-01-02 48.07 17.36 17.28 Down3 002230.SZ 2014-01-06 45.12 17.27 17.29 UP10 002230.SZ 2014-01-15 48.80 17.14 17.10 Down36 002230.SZ 2014-02-27 49.85 19.18 19.48 UP64 002230.SZ 2014-04-09 46.82 16.94 16.86 Down72 002230.SZ 2014-04-21 25.71 16.88 16.91 UP 6）模拟交易 预先设定参数是：本金为100000元，每次都全部买入卖出，即持仓比例为1，手续费为0. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#利用交易信号数据，进行模拟交易#参数：交易信号tdata ,本金capital,持仓比例position,手续费比例feetrade&lt;-function(tdata,capital=100000,position=1,fee=0){ value &lt;- as.numeric(tdata$close) asset &lt;- capital if(tdata[1,]$op=='Down'){ amount &lt;- (asset*position)%/%value[1] cash &lt;- (asset*position)%%value[1] #奇数为0，偶数为asset减去上一次的。 diff &lt;- 0.00 }else if(tdata[1,]$op=='UP'){ amount &lt;- 0 cash &lt;- asset diff &lt;- 0.00 } i&lt;-2 nrow &lt;- nrow(tdata) while(i&lt;=nrow){ #Down 买入 if(tdata[i,]$op=='Down'){ asset &lt;- c(asset,tail(asset,1)) amount &lt;- c(amount,(tail(asset,1)*position)%/%value[i]) cash &lt;- c(cash,(tail(asset,1)*position)%%value[i]+(tail(asset,1)*(1-position))) diff &lt;- c(diff,0.00) }else if(tdata[i,]$op=='UP'){ #UP 卖出 cash &lt;- c(cash,(tail(amount,1)*value[i])+tail(cash,1)) amount &lt;- c(amount,0) asset &lt;- c(asset,tail(amount,1)*value[i]+tail(cash,1)) diff &lt;- c(diff,tail(asset,1)-tail(asset,2)[1]) } i=i+1 } result &lt;- list() result[['ticks']] &lt;- cbind(tdata,cash,amount,asset,diff) indexRise &lt;- c() indexFall &lt;- c() i &lt;- 2 while(i&lt;=nrow){ if(result[['ticks']][i,]$diff &gt; 0){ indexRise &lt;- c(indexRise,i-1,i) }else if(result[['ticks']][i,]$diff &lt; 0){ indexFall &lt;- c(indexFall,i-1,i) } i &lt;- i+1 } result[['rise']] &lt;- result$ticks[indexRise,] result[['fall']] &lt;- result$ticks[indexFall,] return(result)} #设定交易参数，以$10W为本金，满仓买入或卖出，手续为0，传入交易信号。# 查看每笔交易，将会变成一个list，保存每一个qtid的交易记录result#每一个qtid的交易记录tradeList &lt;- list()for(id in qtid){ tradeList[[id]] &lt;- trade(tdata[[id]],100000)} 7）计算收益率，并记录在一个列表里面，生成dataframe，信息包含日期，代码，名称，收益率，涨跌幅，近1周涨跌，近1月涨跌，年初至今涨跌。 123456789101112131415161718192021222324252627income &lt;- c()quoteChangeDaily &lt;- c()quoteChangeWeek &lt;- c()quoteChangeMonth &lt;- c() quoteChangeFYear &lt;- c()for(id in qtid){ #C(),收益率。收益率 = （当天的股价-买入价）/ 买入价 *100% income &lt;- c(income,(tail(tradeList[[id]]$ticks$asset,1)-tradeList[[id]]$ticks$asset[1])/tradeList[[id]]$ticks$asset[1]*100) mktYest &lt;- getDailyQuote(data='mktFwdDaily',qtid = id,startdate=pdata[[id]]$date[nrow(pdata[[id]])-1],enddate=pdata[[id]]$date[nrow(pdata[[id]])-1],key=key) mktWeek &lt;- getDailyQuote(data='mktFwdDaily',qtid = id,startdate=pdata[[id]]$date[nrow(pdata[[id]])-5],enddate=pdata[[id]]$date[nrow(pdata[[id]])-5],key=key) mktMonth &lt;- getDailyQuote(data='mktFwdDaily',qtid = id,startdate=pdata[[id]]$date[nrow(pdata[[id]])-20],enddate=pdata[[id]]$date[nrow(pdata[[id]])-20],key=key) mktFYear &lt;- getDailyQuote(data='mktFwdDaily',qtid = id,startdate=pdata[[id]]$date[1],enddate=pdata[[id]]$date[1],key=key) #涨跌幅 .涨跌幅的计算公式是：(当前最新成交价（或收盘价）-开盘参考价)÷开盘参考价×100% [which(mktYest$qtid==id),] quoteChangeDaily &lt;- c(quoteChangeDaily,(as.numeric(tail(pdata[[id]], 1)$close)-mktYest$close)/mktYest$close*100) #近1周涨跌 quoteChangeWeek &lt;- c(quoteChangeWeek,(as.numeric(tail(pdata[[id]], 1)$close)-mktWeek$close)/mktWeek$close*100) #近1月涨跌 quoteChangeMonth &lt;- c(quoteChangeMonth,(as.numeric(tail(pdata[[id]], 1)$close)-mktMonth$close)/mktMonth$close*100) #年初至今涨跌 quoteChangeFYear &lt;- c(quoteChangeFYear,(as.numeric(tail(pdata[[id]], 1)$close)-mktFYear$close)/mktFYear$close*100)}ChiAbbr &lt;- getMD(data='keyMap',qtid=qtid,key=key)$ChiAbbrmaDF &lt;- data.frame('1'=tail(dailyQuote,1)$date,'2'=qtid,'3'=ChiAbbr, '4'=income,'5'=quoteChangeDaily,'6'=quoteChangeWeek,'7'=quoteChangeMonth, '8'=quoteChangeFYear)#排序maDF &lt;- maDF[order(maDF$X4,decreasing=T),] 8）求取沪深300指数 123456789101112131415161718192021222324hs300&lt;-getDailyQuote(data='mktDataIndex',qtid=c('000300.SH'),startdate=sDate,enddate=eDate,key=key) id &lt;- c('000300.SH')hs300mktWeek &lt;- hs300[nrow(hs300)-5,]hs300mktMonth &lt;- hs300[nrow(hs300)-20,]hs300mktFYear &lt;- hs300[1,]quoteChangeDaily &lt;- (tail(hs300,1)$close-tail(hs300,1)$prevClose)/tail(hs300,1)$prevClose*100quoteChangeWeek &lt;- (tail(hs300,1)$close-hs300mktWeek$close)/hs300mktWeek$close*100quoteChangeMonth &lt;- (tail(hs300,1)$close-hs300mktMonth$close)/hs300mktMonth$close*100quoteChangeFYear &lt;- (tail(hs300,1)$close-hs300mktFYear$close)/hs300mktFYear$close*100hs300Income &lt;- c()hs300Income &lt;- (tail(hs300,1)$close-hs300mktFYear$close)/hs300mktFYear$close*100#生成dataframehs300Dt &lt;- data.frame('1'=tail(dailyQuote,1)$date,'2'='000300.SH','3'='沪深300','4'=hs300Income,'5'=quoteChangeDaily,'6'=quoteChangeWeek,'7'=quoteChangeMonth,'8'=quoteChangeFYear) 沪深300指数的数据是这样的： 123&gt; hs300Dt X1 X2 X3 X4 X5 X6 X7 X81 2016-01-22 000300.SH 沪深300 -14.50151 1.042311 -0.1688989 -18.69586 -14.50151 9）合并数据，并发送到况客投研平台，进行后期的修改。 123maDF &lt;- rbind(hs300Dt,maDF)names(maDF)&lt;-c('日期','代码','名称','收益率(%)','涨跌幅(%)','周涨跌幅(%)','月涨跌幅(%)','年初至今涨跌幅（%）')postData(maDF,name='maDataF',key=key) 这样，便算是完成了。大家如果有什么不明白的话，可以随时艾特我哦。","link":"/2022/07/24/2016-01-14-MACD/"},{"title":"遗传算法的R语言实现","text":"前言遗传算法的操作使用适者生存的原则，在潜在的种群中逐次产生一个近似最优解的方案，在每一代中，根据个体在问题域中的适应度值和从自然遗传学中借鉴来的再造方法进行个体选择，产生一个新的近似解。这个过程会导致种群中个体的进化，得到的新个体比原来个体更能适应环境，就像自然界中的改造一样。 目录 遗传算法原理 R语言实现 1.遗传算法原理在遗传算法里，优化问题的解是被称为个体，它表示为一个变量序列，叫做染色体或者基因串。编码：染色体一般被表达为简单的字符串或数字串，也有其他表示法，这一过程称为编码。基本的过程是： 1)首先要创建种群，算法随机生成一定数量的个体，有时候也可以人工干预这个过程进行，以提高初始种群的质量。在每一代中，每一个个体都被评价，并通过计算适应度函数得到一个适应度数值。种群中的个体被按照适应度排序，适应度高的在前面。（适应度函数） 2)产生下一代个体的种群，通过选择过程和繁殖过程完成。 选择过程，是根据新个体的适应度进行的，但同时并不意味着完全的以适应度高低作为导向，因为单纯选择适应度高的个体将可能导致算法快速收敛到局部最优解而非全局最优解，我们称之为早熟。作为折中，遗传算法依据原则：适应度越高，被选择的机会越高，而适应度低的，被选择的机会就低。初始的数据可以通过这样的选择过程组成一个相对优化的群体。 繁殖过程，表示被选择的个体进入交配过程，包括交配(crossover)和突变(mutation，交配对应算法中的交叉操作。一般的遗传算法都有一个交配概率，范围一般是0.6~1，这个交配概率反映两个被选中的个体进行交配的概率。例如，交配概率为0.8，则80%的“夫妻”个体会生育后代。每两个个体通过交配产生两个新个体，代替原来的“老”个体，而不交配的个体则保持不变。交配过程，父母的染色体相互交換，从而产生两个新的染色体，第一个个体前半段是父亲的染色体，后半段是母亲的，第二个个体则正好相反。不过这里指的半段並不是真正的一半，这个位置叫做交配点，也是随机产生的，可以是染色体的任意位置。 突变过程，表示通过突变产生新的下一代个体。一般遗传算法都有一个固定的突变常数，又称为变异概率，通常是0.1或者更小，这代表变异发生的概率。根据这个概率，新个体的染色体随机的突变，通常就是改变染色体的一个字节（0变到1，或者1变到0）。 遗传算法实现将不断的重复这个过程：每个个体被评价，计算出适应度，两个个体交配，然后突变，产生下一代，直到终止条件满足为止。一般终止条件有以下几种： 进化次数限制 计算耗费的资源限制，如计算时间、计算占用的CPU，内存等 个体已经满足最优值的条件，即最优值已经找到 当适应度已经达到饱和，继续进化不会产生适应度更好的个体 人为干预 过程： 创建初始种群 循环：产生下一代 评价种群中的个体适应度 定义选择的适应度函数 改变该种群（交配和变异） 返回第二步 满足终止条件结束 2.R语言实现一般在进行遗传算法的时候，需要考虑的参数有： 种群规模(Population)，即种群中染色体个体的数目。 染色体的基因个数(Size)，即变量的数目。 交配概率(Crossover)，用于控制交叉计算的使用频率。交叉操作可以加快收敛，使解达到最有希望的最优解区域，因此一般取较大的交叉概率，但交叉概率太高也可能导致过早收敛。 变异概率(Mutation)，用于控制变异计算的使用频率，决定了遗传算法的局部搜索能力。 中止条件(Termination)，结束的标志。 以下是常见的R遗传算法包： mcga包，多变量的遗传算法，用于求解多维函数的最小值。 genalg包，多变量的遗传算法，用于求解多维函数的最小值。 rgenoud包，复杂的遗传算法，将遗传算法和衍生的拟牛顿算法结合起来，可以求解复杂函数的最优化化问题。 gafit包，利用遗传算法求解一维函数的最小值。不支持R 3.1.1的版本。 GALGO包，利用遗传算法求解多维函数的最优化解。不支持R 3.1.1的版本。 那么我们今天就只针对mcga包，还有genalg包进行讲解一下吧。 1)mcga 实值优化问题。使用的变量值表示基因序列，而不是字节码，因此不需要编解码的处理。mcga实现了遗传算法的交配和突变的操作，并且可以进行大范围和高精度的搜索空间的计算，算法的主要缺点是使用了256位的一元字母表。 12345install.packages(&quot;mcga&quot;)library(mcga)#查看mcga的定义mcga 这是mcga的方法定义。 12function (popsize, chsize, crossprob = 1, mutateprob = 0.01, elitism = 1, minval, maxval, maxiter = 10, evalFunc) 参数说明： popsize，个体数量，即染色体数目 chsize，基因数量，限参数的数量 crossprob，交配概率，默认为1.0 mutateprob，突变概率，默认为0.01 maxiter，繁殖次数，即循环次数，默认为10 evalFunc，适应度函数，用于给个体进行评价 elitism，精英数量，直接复制到下一代的染色体数目，默认为1 minval，随机生成初始种群的下边界值 maxval，随机生成初始种群的上边界值 例子：fx=(x1-5)^2 + (x2-55)^2 +(x3-555)^2 +(x4-5555)^2 +(x5-55555)^2 123456789101112131415161718192021# 定义适应度函数 f &lt;- function(x){ #总括号 return ((x[1]-5)^2+(x[2]-55)^2+(x[3]-555)^2+(x[4]-5555)^2+(x[5]-55555)^2)}# 运行遗传算法m &lt;- mcga( popsize=200, chsize=5, minval=0.0, maxval=999999, maxiter=2500, crossprob=1.0, mutateprob=0.01, evalFunc=f)# 最优化的个体结果print(m$population[1,])# 执行时间m$costs[1] 同样，当题目改为fx=(x1-5)^2 + (x2-55)^2 +(x3-555)^2 +(x4-5555)^2 +(x5-55555)^2时候： 12345678910111213141516#这是适应度函数f&lt;-function(x){ return ((x[1]-7)^2 + (x[2]-77)^2 +(x[3]-777)^2 +(x[4]-7777)^2 +(x[5]-77777)^2)}m&lt;-mcga(popsize=200, chsize=5, minval=0.0, maxval=999999999.9, maxiter=2500, crossprob=1.0, mutateprob=0.01, evalFunc=f)cat(&quot;Best chromosome:\\n&quot;)print(m$population[1,])cat(&quot;Cost: &quot;,m$costs[1],&quot;\\n&quot;) 2)genalg包 实现了遗传算法，还提供了遗传算法的数据可视化，给用户更直观的角度理解算法。默认图显示的最小和平均评价值，表示遗传算法的计算进度。直方图显出了基因选择的频率，即基因在当前个体中被选择的次数。参数图表示评价函数和变量值，非常方便地看到评价函数和变量值的相关关系。 12install.packages(&quot;genalg&quot;)library(genalg) 这是genalg函数定义： 1234567rbga(stringMin=c(), stringMax=c(), suggestions=NULL, popSize=200, iters=100, mutationChance=NA, elitism=NA, monitorFunc=NULL, evalFunc=NULL, showSettings=FALSE, verbose=FALSE) stringMin，设置每个基因的最小值 stringMax，设置每个基因的最大值 suggestions，建议染色体的可选列表 popSize，个体数量，即染色体数目，默认为200 iters，迭代次数，默认为100 mutationChance，突变机会，默认为1/(size+1)，它影响收敛速度和搜索空间的探测，低机率导致更快收敛，高机率增加了搜索空间的跨度。 elitism，精英数量，默认为20%，直接复制到下一代的染色体数目 monitorFunc，监控函数，每产生一代后运行 evalFunc，适应度函数，用于给个体进行评价 showSettings，打印设置，默认为false verbose，打印算法运行日志，默认为false 例如：设fx=abs(x1-sqrt(exp(1)))+abs(x2-log(pi))，计算fx的最小值，其中x1,x2为2个不同的变量。 1234567891011121314151617181920212223242526# 定义适应度函数f&lt;-function(x){ return(abs(x[1]-sqrt(exp(1)))+abs(x[2]-log(pi)))} # 定义监控函数monitor &lt;- function(obj){ xlim = c(obj$stringMin[1], obj$stringMax[1]); ylim = c(obj$stringMin[2], obj$stringMax[2]); plot(obj$population, xlim=xlim, ylim=ylim, xlab=&quot;pi&quot;, ylab=&quot;sqrt(50)&quot;);} # 运行遗传算法 在命令行中运行m2 = rbga(c(1,1), c(3,3), popSize=100, iters=1000, evalFunc=f, mutationChance=0.01, verbose=TRUE, monitorFunc=monitor )#计算结果m2$population[1,] 默认图输出，用于描述遗传过程的进展，X轴为迭代次数，Y轴评价值，评价值越接近于0越好。在1000迭代1000次后，基本找到了精确的结果。 1plot(m2) 直方图输出，用于描述对染色体的基因选择频率，即一个基因在染色体中的当前人口被选择的次数。当x1在1.65区域时，被选择超过80次；当x2在1.146区域时，被选择超过了80次。通过直方图，我们可以理解为更优秀的基因被留给了后代。 1plot(m2,type='hist') 参数图输出，用于描述评价函数和变量的值的相关关系。对于x1，评价值越小，变量值越准确，但相关关系不明显。对于x2，看不出相关关系。 1plot(m2,type='vars') 以下是genalg包官方给出的例子： 12345678910111213141516171819202122232425# optimize two values to match pi and sqrt(50)evaluate &lt;- function(string=c()) { returnVal = NA; if (length(string) == 2) { returnVal = abs(string[1]-pi) + abs(string[2]-sqrt(50)); } else { stop(&quot;Expecting a chromosome of length 2!&quot;); } returnVal}monitor &lt;- function(obj) { # plot the population xlim = c(obj$stringMin[1], obj$stringMax[1]); ylim = c(obj$stringMin[2], obj$stringMax[2]); plot(obj$population, xlim=xlim, ylim=ylim, xlab=&quot;pi&quot;, ylab=&quot;sqrt(50)&quot;);}rbga.results = rbga(c(1, 1), c(5, 10), monitorFunc=monitor, evalFunc=evaluate, verbose=TRUE, mutationChance=0.01)plot(rbga.results)plot(rbga.results, type=&quot;hist&quot;)plot(rbga.results, type=&quot;vars&quot;)","link":"/2022/07/24/2016-01-15-Genetic-Algorithms-in-R/"},{"title":"About Hadoop","text":"前言我们知道，互联网近十年的数据增长是呈现爆炸增长的。大型互联网公司每天要处理的数据基本上都是TB级，甚至是PB级的。而为了存储处理这样海量的数据，传统的数据存储策略（关系型数据库）便陷入了瓶颈。不管是数据入库还是查询，使用传统的存储策略都设计到上亿条数据的便利查找操作，显然这使相当考验存储设备的性能的，也是相当耗时的。但我们知道，当代互联网是追求实时性、高用户体验的，这样的等待时间显然是不会被 认可的。 另外，在追求计算机性能的解决方案时，也必然意味着这样的计算机事极其昂贵、无法普及的，就像现在的超算中心一样，只能 是属于少数人的，大规模组织的。不利于小公司的发展，同样也不适应当代互联网的发展趋势。 而且，相比于互联网海量数据的增长速度，这样的一台高性能的机器，是否过不久还适合处理这样不断增长数据，还是一个问题呢。 于是，为适应这样的状况，有人就开始设计出了分布式系统，于是，Hadoop就出现了。 目录1.Hadoop的介绍 2.Hadoop的两大组件 3.Hadoop的实现机制 1.Hadoop的介绍Hadoop是一个分布式计算开源 软件框架。能在有大量廉价的硬件设备组成的集群上运行应用程序，存储处理海量级别数据。 Hadoop的核心组件有两个，分别是分布式存储、分布式文件管理系统HDFS（Hadoop Distributed File System），还有就是分布式计算框架MapReduce。 其实，Hadoop并不是一个原创的软件。因为在Hadoop之前已经有了很多的分布式框架，比如最著名的是Google的GFS、BigTable、MapReduce，Amason的 AWS、微软的Azure和IBM的蓝云。但是这些软件都是闭源的、商业性的。而这时，Hadoop的创建者Doug Cutting就出现了，应Yahoo！的邀请，他开始在Yahoo！带领团队，开发Apache基金会的顶尖项目Hadoop。应该所Hadoop就是个山寨货，他就是Doug Cutting根据Google的三大论文的思想开发出来的，那个分布式计算框架MapReduce与Google的一模一样，连名字都不带改的。但是这并不妨碍Hadoop成为现如今最有影响力的软件。毕竟，这就是开源的力量。 2.Hadoop的两大组件2.1 HDFS Namenode：名称节点，hdfs的管理程序。控制存储和IO交换。保存元数据。 Secondary NameNode ：辅助名称节点。与NomeNode通讯，复制并合并元数据（比如文件命名空间镜像、修改日志），合并为一个文件，并检查文件大小，将就得修改存入本地磁盘，防止文件过大。更新到NameNode之中。这个过程可以简称为“快照”。当NameNode崩溃是，可手动切换成NameNode，代替NameNode完成工作。 dataNode:是数据存储节点。 至于HDFS上面的任务管理器，旧版本的有JobTracker、TaskTracker，而2.x版本之后，为了更便于资源管理，Hadoop便使用ResourceManager替代以上组件。但这里还是以旧版本为例吧。 JobTracker：运工作监控器。行在主服务器Master节点里面，就近运行。操作切割分配监控task。 以上便是Hadoop的基本存储架构。 HDFS典型的部署是在一个专门的机器 运行NameNode，集群中的其他机器各运行一个DataNode，当然，也可以在运行NameNode的机器上面运行DataNode，或者一个机器运行多个DataNode。一个集群只能有一个NameNode。 NameNode使用事务日志（EditLog）来记录HDFS元数据的变化，使用映射文件（FSImage）存储文件系统的命名空间，包含文件的映射、文件的属性信息等。事务日志和映射文件都存储在NameNode的本地文件系统之中。NameNode启动时，从磁盘中读取映射文件和事务日志，把事务日志的事务都应用到内存中的映射文件上，然后将新的元数据刷新到本地磁盘的新的映射文件上，这样可以截去旧的事务日志，这个过程称为检查点（CheckPoint）。HDFS还设有Secondary NameNode节点，他辅助NameNode处理映射文件和事务日志。NameNode启动的时候合并映射文件和事务日志，而Secondary NameNode周期性的从NameNode复制映射和事务日志到临时目录里面，合并成新的映射文件后再重新上传给NameNode，NameNode更新映射文件并处理事务日志，使得事务日志的大小始终控制在可配置的限度之下。 2.2 MapReduceM/R就是Hadoop底下的并行计算模型。顾名思义，他就是有Map还有Reduce两个部分组成的 。Map是把一组数据一对一的映射成为另外的一组数据，Reduce是对一组数据进行归约，映射和归约分别有一个函数指定。具体的就交由大家在具体项目开发的时候在体会了，这样效果更佳哦。 3.Hadoop的实现机制1.机柜意识通常，大型的HDFS集群跨多个安装点（机柜）排列。一个安装点中的不同节点之间的网络流量通常比跨安装点的网络流量更加的高校。一个NameNode尽量将一个块的多个副本放在多个安装点上以提高容错能力。但是，要平衡容错能力与网络流量的话，HDFS就允许管理员决定一个节点属于哪个安装点，于是，每一个节点就都可以知道它的机柜ID，也就是说，具有了机柜意识。 NameNode可以通过DataNode的机柜ID识别它们的位置。 2.冗余备份HDFS是一个大集群、跨机器、可靠存储的大型文件系统。每个文件都存储在一个个的数据块之中，默认数据块大小为64MB。同一个文件中除了最后一块以外的所有都是一样大的。文件的数据块通过复制备份来保证容错。当然，文件的数据块的大小和复制因子都是可以进行配置的。 HDFS的文件都是一次性写入的，并且都是严格限制任何时候都是一个写用户。DataNode使用本地文件系统来存储HDFS的数据，但是它对于HDFS的文件是一无所知的，只是使用一个个文件来存储HDFS的数据块。每当DataNode启动的时候，都会先进行一次对于本地文件系统的便利，得到一份关于HDFS数据块与本地额对应关系列表，并把这个列表报告发给NameNode。这表示块报告，块报告包含了DataNode上所有块的列表。 3.副本存放HDFS集群一般运行在多个机架之上，不同的机架上机器的通信是通过交换机的。通常，机架内节点之间的带宽比跨机架节点之间的带宽大、更快，而这会影响HDFS的可靠性以及性能。而HDFS会通过机架感知（Rack-aware，NameNode可以确定每个机架的所属的ID）来改进平衡数据可靠性。 一般，当复制因子是3的时候，HDFS的数据块备份策略是，将两个副本放在同一个机架的不同节点上，最后一个副本放在另外的一个机架的节点上。这样就可以防止整个机架失效的时候数据丢失。 4.HDFS心跳因为在这样的大型集群里面，宕机是一种常态。所以，NameNode与DataNode之间的连通性，随时有可能会失效。因此，每个DataNode都会主动向NameNode发送定期心跳信息，如果NameNode没有接收到对应的DataNode的心跳信息，就表明连通性丧失。然后，NameNode会将不能响应心跳信息的DataNode标记为“死DataNode”，并不再向他们发送请求，而存储在该DataNode节点上的数据将不再对那个节点的HDFS客户端可用，该节点将被从系统中有效的移除。如果一个DataNode的死导致数据库的复制因子降到最小值以下，NameNode将会启动附加复制，将复制因子带回正常阶段。 5.安全模式HDFS启动是时，NameNode会进入一个特殊的模式，安全模式，此时不会出现数据块的复制。NameNode会受到个DataNode的心跳信息以及数据块报告。数据块报告中包含一个DataNode所拥有的数据块列表，每个数据块里面都有指定书目的副本。当某个NameNode登记的数据复制品达到最小数目（&lt;=最小数目）时，数据块会被认为是安全的，安全复制。在一定百分比（可配置）的数据块被NameNode检测确定是安全登记之后，在登记（加上附加的30秒），NameNode会推出安全模式。当检测到副本数不足的数据块时，该数据块会被复制到其他的节点之上，以达到最小副本数。 6.数据完成性检测从DataNode中获取的数据块可能会是损坏的。为此，HDSF客户端实现了对于HDFS文件内容的校验和检查（Checksum）。在HDFS文件被创建时，会计算每个数据块的检验和，并将检验和作为一个单独的隐藏文件保存在命名空间里面。当获取这个文件后，会检查各个DataNode取出的数据块和相应的校验和进行匹配。如若不匹配，则会选择其他副本的DataNode去数据块。 7.空间回收当文件被删除是，文件会被移动到/trash目录下，只要还在这个目录之下，文件就可以被快速回复。文件在这个目录里面的时间是可以设置的，超过这个时间，系统就会把它从系统的命名空间之中删除。而文件的删除便会引起相应数据块的释放。 8.元数据磁盘失效映射文件和事务日志是HDFS的核心数据结构。若果这些文件损坏，将会导致HDFS的不可用。当然，可以设置NameNode支持维护映射文件和事务日志的多个副本，任何映射文件或事务日志的修改都会同步到他的副本上。每次NameNode重启时，都会选择最新的一致性的映射文件和事务日志。 9.快照快照支持存储某一个时间点的数据复制。利用这一特性可以将损坏的HDFS回滚到以前的某一个正常的时间点。 以上便是最近的一些心得，还请斧正。","link":"/2022/07/24/2016-01-16-Hadoop-Brief/"},{"title":"R语言实现PageRank","text":"前言当今，一个算法能够支撑起一个商业帝国，这句话还真不是吹的，你看Google就知道了。Google当年就是靠PageRank雄起的，将网页搜索业务做得风生水起。 而今天，我们就来看看如何使用R语言来实现PageRank算法的。 目录1.PageRank的原理 2.PageRank实现步骤 3.R代码实现 1.PageRank的原理其实说白了，PageRank原理就是： PageRank让链接来”投票” 一个页面的“得票数”由所有链向它的页面的重要性来决定。到一个页面的超链接相当于对该页投一票。 一个页面的PageRank是由所有链向它的页面（“链入页面”）的重要性经过递归算法得到的。 一个有较多链入的页面会有较高的等级，相反如果一个页面没有任何链入页面，那么它没有等级。 PageRank的计算基于以下两个基本假设： 数量假设：如果一个页面节点接收到的其他网页指向的入链数量越多，那么这个页面越重要。 质量假设：指向页面A的入链质量不同，质量高的页面会通过链接向其他页面传递更多的权重。所以越是质量高的页面指向页面A，则页面A越重要。 要提高PageRank有3个要点： 反向链接数 反向链接是否来自PageRank较高的页面 反向链接源页面的链接数 基于以上特点，我们再来看看PageRank的基本公式吧。 2.PageRank实现步骤 构造邻接矩阵 列：源页面 行：目标页面 概率矩阵(转移矩阵) 计算公式在这儿体现跟连接数有关的 求开率矩阵的特征值 一般使用的是迭代的算法。当然也可以使用R中的API直接给出特征值。而是用迭代的话，在一轮更新页面PageRank得分的计算中，每个页面将其当前的PageRank值平均分配到本页面包含的出链上，这样每个链接即获得了相应的权值。而每个页面将所有指向本页面的入链所传入的权值求和，即可得到新的PageRank得分。当每个页面都获得了更新后的PageRank值，就完成了一轮PageRank计算。 3.R代码实现分别用下面3种方式实现PageRank: 未考虑阻尼系统的情况 包括考虑阻尼系统的情况 直接用R的特征值计算函数 但是，在这之前，我们还有新建一个page.csv文件，方便我们后面的实现说明。 12345671,21,31,42,32,43,44,2 1)未考虑阻尼系统的情况以下是函数定义。 12345678910111213141516171819202122232425262728293031#构建邻接矩阵adjacencyMatrix&lt;-function(pages){ n&lt;-max(apply(pages,2,max)) A &lt;- matrix(0,n,n) for(i in 1:nrow(pages)) A[pages[i,]$dist,pages[i,]$src]&lt;-1 A}#变换概率矩阵probabilityMatrix&lt;-function(G){ # 按列相加 cs &lt;- colSums(G) cs[cs==0] &lt;- 1 n &lt;- nrow(G) A &lt;- matrix(0,nrow(G),ncol(G)) for (i in 1:n) A[i,] &lt;- A[i,] + G[i,]/cs A}#递归计算矩阵特征值。跟权重有关的eigenMatrix&lt;-function(G,iter=100){ # iter&lt;-10 n&lt;-nrow(G) x &lt;- rep(1,n) # 迭代,x为每一轮计算的权重，也是pR值。 for (i in 1:iter) x &lt;- G %*% x x/sum(x)}pages&lt;-read.table(file=&quot;page.csv&quot;,header=FALSE,sep=&quot;,&quot;)names(pages)&lt;-c(&quot;src&quot;,&quot;dist&quot;);pages 以下便开始执行程序。 1234567891011121314151617181920212223&gt; A&lt;-adjacencyMatrix(pages);A [,1] [,2] [,3] [,4][1,] 0 0 0 0[2,] 1 0 0 1[3,] 1 1 0 0[4,] 1 1 1 0&gt; G&lt;-probabilityMatrix(A);G [,1] [,2] [,3] [,4][1,] 0.0000000 0.0 0 0[2,] 0.3333333 0.0 0 1[3,] 0.3333333 0.5 0 0[4,] 0.3333333 0.5 1 0&gt; q&lt;-eigenMatrix(G,10);q [,1][1,] 0.0000000[2,] 0.4036458[3,] 0.1979167[4,] 0.3984375 2)包括考虑阻尼系统的情况dProbabilityMatrix是对于adjacencyMatrix函数的重构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#变换概率矩阵,考虑d的情况dProbabilityMatrix&lt;-function(G,d=0.85){ cs &lt;- colSums(G) cs[cs==0] &lt;- 1 n &lt;- nrow(G) # (1-d)/n delta &lt;- (1-d)/n A &lt;- matrix(delta,nrow(G),ncol(G)) for (i in 1:n) A[i,] &lt;- A[i,] + d*G[i,]/cs A}&gt; pages&lt;-read.table(file=&quot;page.csv&quot;,header=FALSE,sep=&quot;,&quot;)&gt; names(pages)&lt;-c(&quot;src&quot;,&quot;dist&quot;);pages src dist1 1 22 1 33 1 44 2 35 2 46 3 47 4 2&gt; A&lt;-adjacencyMatrix(pages);A [,1] [,2] [,3] [,4][1,] 0 0 0 0[2,] 1 0 0 1[3,] 1 1 0 0[4,] 1 1 1 0&gt; G&lt;-dProbabilityMatrix(A);G [,1] [,2] [,3] [,4][1,] 0.0375000 0.0375 0.0375 0.0375[2,] 0.3208333 0.0375 0.0375 0.8875[3,] 0.3208333 0.4625 0.0375 0.0375[4,] 0.3208333 0.4625 0.8875 0.0375&gt; q&lt;-eigenMatrix(G,100);q [,1][1,] 0.0375000[2,] 0.3738930[3,] 0.2063759[4,] 0.3822311 增加阻尼系数后，ID=1的页面，就有值了PR(1)=(1-d)/n=(1-0.85)/4=0.0375，即无外链页面的最小值。 3)直接用R的特征值计算函数增加的函数：calcEigenMatrix用于直接计算矩阵特征值，可以有效地减少的循环的操作，提高程序运行效率。 123456789101112131415161718192021222324252627282930313233#直接计算矩阵特征值.即特解calcEigenMatrix&lt;-function(G){ x &lt;- Re(eigen(G)$vectors[,1]) x/sum(x)}&gt; pages&lt;-read.table(file=&quot;page.csv&quot;,header=FALSE,sep=&quot;,&quot;)&gt; names(pages)&lt;-c(&quot;src&quot;,&quot;dist&quot;);pages src dist1 1 22 1 33 1 44 2 35 2 46 3 47 4 2&gt; A&lt;-adjacencyMatrix(pages);A [,1] [,2] [,3] [,4][1,] 0 0 0 0[2,] 1 0 0 1[3,] 1 1 0 0[4,] 1 1 1 0&gt; G&lt;-dProbabilityMatrix(A);G [,1] [,2] [,3] [,4][1,] 0.0375000 0.0375 0.0375 0.0375[2,] 0.3208333 0.0375 0.0375 0.8875[3,] 0.3208333 0.4625 0.0375 0.0375[4,] 0.3208333 0.4625 0.8875 0.0375&gt; q&lt;-calcEigenMatrix(G);q[1] 0.0375000 0.3732476 0.2067552 0.3824972","link":"/2022/07/24/2016-01-16-PageRank-R/"},{"title":"Java Garbage Collection Mechanism","text":"前言所谓“java”，其实不只是一门语言，而是一种设计的美丽，更是一种关于世界观、关于架构之美的映射。 java的底层架构，一个我所未知的世界，一个我想了解的世界。所以，我开始结识到java虚拟机(JVM)，以及java之中的垃圾收集机制。 目录1.JVM 2.Java Garbage Collection Mechanism 3.Java GC 1.JVM既然我们时常说到”JVM(java虚拟机)”，那么所谓的java虚拟机到底是什么吗？我认为他应该是这样的： java虚拟机，Java Virtual Machine，跟我们平常使用的Virtual PC或者VMware一样，是在操作系统上面运行的，一类模仿操作系统环境，虚构出来的计算机。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。不过，VMware等是属于系统虚拟机，而JVM是属于程序虚拟机。 既然我们都说java虚拟机十分重要，那么他为什么这么重要呢？ 我们都曾弄过java的环境配置，都知道，要从Oracle官网下载jdk进行安装，知道jdk里面含有Jre，知道我们要设置计算机的环境路径。但是，对于新手来说，可能不知道，我们做这些工作，其实都是在做一件事情——配置java的虚拟机。我们所编写的java程序，经过编译之后，会生成可以在Java虚拟机上运行的字节码文件。因为每一个可以运行java程序的计算机，都拥有java虚拟机，拥有一样的运行环境。所以，在一种平台下编译生成的字节码文件，便可以在不同的平台下运行。 综上可知，JVM的优势是：屏蔽具体平台的信息，实现跨平台开发。 一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 显然，没有JVM，java将不会有今天这般的辉煌。那么，JVM具体上是如何工作的呢？ JVM的工作： 1、先通过调用jdk之中的java.exe，来让操作系统装载jvm。 2、配置jvm的环境： 1）创建JVM装载环境和配置 2）装载JVM.dll 3）初始化JVM.dll并挂界到JNIENV（JNI调用接口）实例 4）调用JNIENV实例装载并处理class类 JVM在整个jdk中处于最底层的，负责操作系统的交互，用来屏蔽操作系统环境，提供一个完整的java运行环境。 首先是将JVM装入环境，JVM提供的方式是操作系统的动态链接文件。既然是装载JVM的文件，那么操作系统会在你的path下面找到你的程序的java.exe，再从里面通过各种调用寻找jvm.dll以及jvm.cfg，将其装载到操作系统，这样就可以在java中调用JVM的函数了。这些工作做完之后就开始运行java程序了。 Java程序有两种方式一种是jar包，一种是class. 运行jar,Java -jar XXX.jar运行的时候 1、Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例，然后调用Java类 Java.util.jar.JarFileJNIEnv中方法getManifest()并从返回的Manifest对象中取getAttributes(“Main-Class”)的值即jar包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。 2、之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。main函数直接调用Java.c中LoadClass方法装载该类。 如果是执行class方法。main函数直接调用Java.c中LoadClass方法装载该类。 2.Java Garbage Collection Mechanism既然，我们已经了解到了何为“JVM”，那么我们也要接着了解一下，JVM是如何进行平时的内存分配的？ 过去的语言（如C语言）要求程序员显示的分配内存、释放内存。程序在需要时分配内存，不需要时释放内存。但是这种做法常常会引起“内存泄漏”，即是说，由于某种原因是分配的内存始终没有得到释放。如果该任务不断地重复，程序最终会耗尽内存并异常终止，至少无法正常的运行下去。相比之下，java不要求程序员显式的分配内存和释放内存，避免了很多的潜在问题。java在创建对象时自动分配内存，并当该对象的引用不存在是释放这块内存。 而这也就是，java垃圾回收机制，java相对于以前的语言的优势。 java的垃圾收集机制，gc（garbage collection），是指JVM用于释放哪些不在会用的对象所占用的内存。，虽说，java语言并没有要求JVM有gc，也没有规定gc要如何进行工作，但是，常用的JVM都有GC，而且，大多数gc都使用类似的算法管理内存，和执行收集操作。 但是一般的，在java语言之中，判断一块内存空间是否符合垃圾回收器标准的标准只有两个： 给对象赋予了控制null，以后再没有调试过。 给对象赋予了新值，即重新分配了内存空间。 注：一块内存空间符合了垃圾回收器的收集标准，并不意味着这块内存控件就一定会被垃圾回收器收集。 虽说，java是自动进行内存的分配与释放的。但是，我们也可以使用System.gc()方法做到强制执行。但是，并不保证每次调用System.gc()方法就一定能够启动垃圾回收，他只不过会向jvm发出这样的一个申请，但是当地会不会真正执行垃圾回收，一切都是未知数。 所以，我们可以在执行system.gc()前，先执行finalize()方法，对对象进行强制释放内存。虽说，在没有明确释放内存志愿的情况下，java也会隐形的调用finalize()方法,终止对象，以此来释放资源。 3.Java GC1.首先来看一下JVM内存结构，它是由堆、栈等部分组成，结构图如下所示。 1.1 堆 所有通过new创建的对象的内存都在堆中分配。显然，如果不对堆中的这些对象内存进行分类的话，是多而杂的。在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。 年轻代: 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 年老代: 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代: 用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 1.2 栈 每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。 2.VM垃圾回收机制针对上述的分类，GC有两种类型：Scavenge GC和Full GC。 2.1 Scavenge GC 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 2.2 Full GC 对整个堆进行整理，包括Young、Tenured和Perm。因为需要对整个块进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： 年老代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显示调用 上一次GC之后Heap的各域分配策略动态变化 下次跟大家，分享一下，垃圾回收机制的几个算法问题吧。","link":"/2022/07/24/2016-01-17-Java-Garbage-Collection-Mechanism/"},{"title":"RoboCup Rescue 2015 – Rescue Simulation League Team Description S.O.S (Iran)","text":"前言这是我过去一年一直在准备并参与的一个比赛RoboCup Recuse Similation League。虽然现在比赛已经结束，但还是抽出时间整理了下以前的东西。为了下届学弟学妹们，也翻译了些许文章。而这一片是描述我们在世界级别比赛上的最大的对手，世界冠军S.O.S。这是原文链接。以下便开始翻译内容。 目录 摘要 介绍 Agent 摘要：SOS团队是众所周知的，在救援仿真联赛中表现出色。我们已经在这个比赛中取得了很多的奖项。去年，我们在巴西举行的机器人世界杯获得第一名。我们团队已经发展了多年，主要是老成员，这些年在不同的比赛中我们的基本代码的得分非常稳定，本文旨在提高老战略和解决新出现的逻辑错误和增加新的功能。 1.介绍该S.O.S.基础AT的能力和技能，在往年的TDP（2010- 2014年）进行了说明，因此本文所要描绘的是我们的计划，就2015年机器人世界杯新战略的细节改进进行介绍。 去年SOS成员开发全速和低速通信，但到2015年机器人世界杯大赛SOS的主要重点是没有沟通的地图，这种方式专门为消防官兵和警察部队AT创造。在自然灾害中所有类型的事件会发生。正因为如此，在最困难的情况下，我们将执行这么多的活动，来操纵我们的代码。 2 agent2.1 警察我们去年的TDP没有讨论被添加到Policeforce代码的新功能。因此，在今年的TDP，我们注重描写警察的算法和方法。 2.1.1 清理系统改变在2013年模拟服务器中大量的AT卡在地图上的陡峭的边缘问题。定义此问题时必须指出的是，当AT是停留在一个凹区域，其他代理将包围它并引起排斥力卡ＡＴ。其结果是，大量的时间将在释放该ＡＴ的过程中被浪费。 清理时与街道不具有相同的方向原因。道路有在关节角的方向之间的陡峭的角度，这将导致在凹形区域中的间隙的棱角产生影响。简单和基本的解决办法是清除整条道路，但我们已经避免了，因为这会浪费大量的周期。 该SOS警方已经设计和开发新的系统和算法，将减小卡在边缘AT的概率。清除时，我们的算法考虑到所有的未来路径，然后选择最佳路径（基于接下来的步骤），同时考虑所有选项（而不是选择和清除的道路的主要方向），这将导致降低卡在陡峭的边缘可能性。图（1）图（2），我们可以比较SOS新的结算方法，由浙江大学队结算。 2.1.2 消防队到达火区一个在警察部队的其他变动是增加了中断状态，用于帮助消防队处理火灾。如果一个警察看到或感知火灾发生后，AT开始估计火灾的大小。如果猜测，火灾是相当小的尺寸，警方会放弃自己的任务，首先释放消防大队AT和火之间的路径，所以大火将更快熄灭。 2.1.3 检查火灾的概率状态加入警队的另一个特点是检查火灾概率状态。在这种状态下，如果警方检测一些建筑物的高温，AT开始估计火灾可能发生。如果发生火灾的地区是ＡＴ附近，ＡＴ将清除道路，所以可以阻止火灾发生。 2.1.4 无通讯世界模型我们的警察部队也更新与消防队的通讯，这是在没有通信战略的世界模型下。在没有沟通的策略下，如果ＡＴ检测火的集群，遵循火找到它的边界。但是，什么是比找到火并通知火的新信息消防大队代理更重要。警方代理发现消防大队的负责灭火，并更新了消防的信息。由于没有沟通，根据他们的旧世界模式不明，为消防队的最有可能的地方，警方搜查了代理商的确切位置。然后警察代理更新世界模型的每个消防队的信息，如果火剂的最后一次更新的时间超过15个周期。","link":"/2022/07/24/2016-01-19-Rescue-Simulation-League-Team-Description-S.O.S-(Iran)/"},{"title":"OpenCV with CodeBlocks","text":"前言近年，机器学习当火。而OpenCV便是机器学习在图像识别领域的热门框架。恰好近来闲来无事，便开始捣鼓一番OpenCV。 目录 OpenCV介绍 minGW版OpenCV配置方式 CodeBlocks IDE示例代码实现 1.OpenCV介绍OpenCV的全称是：Open Source Computer Vision Library。OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。 为什么有OpenCV？ 计算机视觉市场巨大而且持续增长，且这方面没有标准API，如今的计算机视觉软件大概有以下三种： 研究代码（慢，不稳定，独立并与其他库不兼容） 耗费很高的商业化工具（比如Halcon, MATLAB+Simulink） 依赖硬件的一些特别的解决方案（比如视频监控，制造控制系统，医疗设备）这是如今的现状。而标准的API将简化计算机视觉程序和解决方案的开发。OpenCV致力于成为这样的标准API。 OpenCV致力于真实世界的实时应用，通过优化的C代码的编写对其执行速度带来了可观的提升，并且可以通过购买Intel的IPP高性能多媒体函数库(Integrated Performance Primitives)得到更快的处理速度。 主要应用方向有：人机互动，人脸识别，运动跟踪，图像分割等等。 2.minGW版OpenCV配置方式首先，我们来看看需要准备的什么吧。 Win7系统 mingw-get-setup.exe opencv-2.4.9.exe cmake-3.2.0-rc1-win32-x86.exe 然后，双击opencv-2.4.9.exe，这是opencv的一个自解压程序，指定好安装目录，他将自动把.exe里的文件解压到指定目录。现在，咱们来看看OpenCV的目录结构吧。 opencv build、sources build doc、include、java、python、x64、x86、LICENSE、OpenCVConfig.cmake、OpenCVConfig-version.cmake 可知，在opencv目录下有两个文件夹，分别为build、以及source。其中source是OpenCV的源码。而build是各个语言版本编译过后的库文件，包含c、c++、java、python等语言。x86文件夹和x86文件夹分别对应的是32-bit、64-bit系统下的库。在x64、x86中，有如下目录结构： vc10、vc11、vc12 分别对应的是Virtual Studio2010、2011、2012编译后的库。因为不同的编译器(即便相同的编译器，但不同版本，编译后的文件也是不同的)。同编译器编译出来的OpenCV，只能在相应的编译环境下运行。在早前的如OpenCV 2.3.1中还有vc9（对应vs2008）和mingw版本，而在2.4版本之后便只有vc系列了。 而现在，因为我们使用的编译器是MinGW，而该版本的OpenCV没有对应的编译后文件，所以，我们不得不来自己对源码进行编译。 那么，接下来，我们便开始编译工作了。 1)安装MinGW。 很简单。直接双击，指定安装目录，确认安装即可。 2)出现以下界面，至少点击以下两图所示的条目，并安装。 3)安装cmake 4)运行cmake，在where is the source code中填入OpenCV源代码文件的路径，比如：“…/opencv_2410/sources”；在where to build the binaries中填入编译文件需要存放的路径，比如：“…/MinGW/Debug”(存放路径文件自己定义新建一个即可)。(三点表示省略) 5)点击“Configure”;在Specify the generator for this project中选择MinGW Makefiles(选择刚刚安装的MinGW或者本机已有的)，选中Specify native compilers，点击“Next”。 6)选择编译器路径，这里Compilers: C 选择目录为“…/MinGW/bin/gcc.exe”; C++ 选择目录为 “…/MinGw/bin/g++.exe”，点击“Finish” 7)然后再次点“Configure” 8)等走完进度条，选择需要的Generate选项，此处可以不操作直接点“Generate”，走完进度条便生成了“MinGW Makefiles” 9)之后用mingw对其进行编译，cmd打开命令提示符窗口，进到刚才的保存目录，这里是“…/opencv2.4.10/MinGW/Debug”，输入“mingw32-make”，回车；等待运行完毕后，输入 mingw32-make install,回车；（此过程大约需1-2个小时） 10)运行完毕后便生成了mingw版的OpenCV库，进入“…/opencv2.4.10/MinGW/Debug/install”文件夹，便可以看到所需的头文件和库文件 3.CodeBlocks IDE示例代码实现我所选用的IDE是 codeblocks-13.12mingw-setup.exe codeblocks默认使用的编译器是MinGW。 1)双击安装codeblocks 2)启动codeblocks，新建一个“Console application”项目，任意取一个名字。 3)测试代码如下 123456789101112#include &quot;cv.h&quot; #include &quot;highgui.h&quot; int main() { IplImage* img = cvLoadImage(&quot;test.jpg&quot;); cvNamedWindow( &quot;test&quot;, 0 ); cvShowImage(&quot;test&quot;, img); cvWaitKey(0); cvReleaseImage( &amp;img ); cvDestroyWindow( &quot;test&quot; ); return 0; } 4)设置opencv相关头文件以及库文件路径 这一步是关键。因为还是有点麻烦的。 (1)右击项目名称，选build options： (2)弹出窗口，首先添加头文件路径，依次点击：Search directories-&gt;Complier-&gt;Add，选择头文件所在目录 (3)选择库文件路径，依次点击Linker-&gt;Add，选择vc10下的lib库路径 (4)最后点击 Linker settings，添加相应库文件，这里如果不知道自己会用到那些库文件的话，可以将vc10/lib下的所有库文件全部添加进去 5)动态库调用设置 两种方法任选其一即可： 1.可以设置系统变量，将“…\\opencv\\build\\x86\\vc10\\bin;”添加到系统变量中 2.将…\\opencv\\build\\x86\\vc10\\bin下的所有dll文件复制到codeblocks对应工程下的bin\\Debug文件夹下即可（如果会分辨opencv库文件的话，也可以只将用到的动态库复制即可）。","link":"/2022/07/24/2016-01-20-OpenCV-with-CodeBlocks/"},{"title":"Gaussian Blur","text":"前言玩了OpenCV之后，感觉自己能分分钟写出个PS软件，真是嘚瑟了。不过，这倒是也是个方向。所以，现在就来写个滤镜吧。 说到底，在计算机眼中，所谓的图片就是一个矩阵，对于他的处理跟线性代数是极其相关的，所以大学狗还是认真学习去吧。好了，不闹了。说到滤镜，说到矩阵，当然要想到PS软件里面的”Gaussian Blur”啦。 目录 Gaussian Blur的介绍 Gaussian Blur的原理 Gaussian Blur的例子以及代码实现 1. Gaussian Blur的介绍高斯模糊（英语：Gaussian Blur），也叫高斯平滑，是在Adobe Photoshop、GIMP以及Paint.NET等图像处理软件中广泛使用的处理效果，通常用它来减少图像噪声以及降低细节层次。 这种模糊技术生成的图像，其视觉效果就像是经过一个半透明屏幕在观察图像，这与镜头焦外成像效果散景以及普通照明阴影中的效果都明显不同。高斯平滑也用于计算机视觉算法中的预先处理阶段，以增强图像在不同比例大小下的图像效果。 从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作高斯分布，所以这项技术就叫作高斯模糊。图像与圆形方框模糊做卷积将会生成更加精确的焦外成像效果。由于高斯函数的傅立叶变换是另外一个高斯函数，所以高斯模糊对于图像来说就是一个低通滤波器。 本文介绍”高斯模糊”的算法，这是一个非常简单易懂的算法。本质上，它是一种数据平滑技术（data smoothing）。 2. Gaussian Blur的原理 所谓”模糊”，可以理解成每一个像素都取周边像素的平均值。 是的，”平均值”是模糊的关键。他能够将清晰度高的照片，运用平均值，将图片的细节隐藏，使这个像素矩阵的变化更为平滑。 咱们先来看看个例子： 还未进行模糊处理过的图片，里面的像素数值是不定，细节暴露的。就比如上图，中间数值是2，周边是1。 “中间点”取”周围点”的平均值，就会变成1。在数值上，这是一种”平滑化”。在图形上，就相当于产生”模糊”效果，”中间点”失去细节。 显然，计算平均值时，取值范围越大，”模糊效果”越强烈。 上面分别是原图、模糊半径3像素、模糊半径10像素的效果。模糊半径越大，图像就越模糊。从数值角度看，就是数值越平滑。 这就是模糊的原理。而以上这个例子的模糊算法便是最常见的3x3模板的均值模糊，即取一定半径内的像素值之平均值作为当前点的新的像素值。 其实，这个时候，本文也算是结束了。因为，你会发现，其他图像模糊算法是大同小异的，只是在求均值的时候因为侧重点的不同而赋予这个矩阵的各个像素点以不同的权重而已。不过，我还是会继续讲下去的，不然会被打死。 那么我们接着来，大家一定听说过’Gaussian’这位伟大的学者吧。那么他有名的”高斯分布”，也就是”正态分布”也是知道的吧。对的，就是你想的那样。所谓的”高斯模糊”，就是将高斯分布和模糊两者结合起来的，然后就随随便便的冠上了伟大的”Gsussian”的名头，让人还以为高大上，很难，其实就是求均值。 前面我们说到了”权重”，是想让这个矩阵中筛选出对于中间点是相对更加重要的点，并给它在求均值的时候更大的影响力。而高斯模糊中的权重函数，真是高斯分布。 由高斯分布可以知道，距离中点越近的点，显然他的权重是越大的；相反，越远，权重就越小。 计算平均值的时候，我们只需要将”中心点”作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。 接下来祭出高斯分布的密度函数的计算公式： 其中，μ是x的均值，σ是x的方差。因为计算平均值的时候，中心点就是原点，所以μ等于0。 又因为像素矩阵是二维的，而现在这个密度函数是一维的。根据一维高斯函数，可以推导得到二维高斯函数： 3. Gaussian Blur的步骤以及代码实现根据高斯模糊的原理，我们已经知道，要根据二维高斯函数求取像素矩阵的均值，以此来进行模糊处理。 1）求取权重矩阵 咱们还是使用的阮一峰老师博客的例子： 假定使用的3x3模板，中心点的坐标是（0,0），那么距离它最近的8个点的坐标如下，更远的点以此类推： 为了计算权重矩阵，需要设定σ的值。假定σ=1.5，分别将这个九宫格中的各个点的坐标代入上面的二维高斯函数计算公式，求出各自的G(x,y).则模糊半径为1的权重矩阵如下： 这9个点的权重总和等于0.4787147，如果只计算这9个点的加权平均，还必须让它们的权重之和等于1，因此上面9个值还要分别除以0.4787147，得到最终的权重矩阵。 2）计算高斯模糊 就是说计算中间点的值。 假设现有9个像素点，灰度值（0-255）如下： 各自乘上各自对应的权重。 将这九个值相加即可得到中间点的数值。这就是中间点高斯模糊值。 对所有点重复这个过程，就得到了高斯模糊后的图像。如果原图是彩色图片，可以对RGB三个通道分别做高斯模糊。 对于边缘的点，就是把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。 那么接下是代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.awt.Color;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO; public class GaussianBlur { /** * 简单高斯模糊算法 * @param args * @throws IOException [参数说明] * @return void [返回类型说明] * @exception throws [违例类型] [违例说明] * @see [类、类#方法、类#成员] */ public static void main(String [] args) throws IOException { BufferedImage img = ImageIO.read(new File(&quot;BigData.jpg&quot;)); System.out.println(img); int height = img.getHeight(); int width = img.getWidth(); /** * 计算一个九宫格的平均值 */ int[][] matrix = new int[3][3]; int[] values = new int[9]; for (int i = 0;i&lt;width;i++){ for(int j = 0;j&lt;height;j++){ readPixel(img,i,j,values); fillMatrix(matrix,values); img.setRGB(i, j, avgMatrix(matrix)); } } ImageIO.write(img,&quot;jpeg&quot;,new File(&quot;test.jpg&quot;));//保存在工程为test.jpeg文件 } private static void readPixel(BufferedImage img, int x, int y, int[] pixels){ int xStart = x - 1; int yStart = y - 1; int current = 0; // for (int i=xStart;i&lt;3+xStart;i++){ for(int j=yStart;j&lt;3+yStart;j++){ int tx=i; if(tx&lt;0){ tx=-tx; }else if(tx&gt;=img.getWidth()){ tx=x; } int ty=j; if(ty&lt;0){ ty=-ty; }else if(ty&gt;=img.getHeight()){ ty=y; } pixels[current++]=img.getRGB(tx,ty); } } } private static void fillMatrix(int[][] matrix, int... values) { int filled=0; for(int i=0;i&lt;matrix.length;i++){ int[] x=matrix[i]; for(int j=0;j&lt;x.length;j++){ x[j]=values[filled++]; } } } private static int avgMatrix(int[][] matrix){ int r=0; int g=0; int b=0; for(int i=0;i&lt;matrix.length;i++){ int[] x=matrix[i]; for(int j=0;j&lt;x.length;j++){ if(j==1){ continue; } Color c=new Color(x[j]); r+=c.getRed(); g+=c.getGreen(); b+=c.getBlue(); } } return new Color(r/8,g/8,b/8).getRGB(); }} 再来个wiki上面的例子吧，大家可以巩固一下：","link":"/2022/07/24/2016-01-22-Gaussian-Blur/"},{"title":"Ambition","text":"野心，你有想要颠覆这个星球的野心吗？ 有点中二，有点热血，一句话可以点燃撩在心头的蠢动。原本有点玩笑意味的话，却是一些人一生的信条。这就是我在钢总和刀哥身上看到的。 前几天，有幸能够听到原WPS技术副总裁、现中科云华CEO杨钢钢总，以及原阿里金融CTO、小米金融总经理、现福米信息CEO王安全刀哥的分享，能够跟他们坐一起畅聊。这是一次难得的机会，倾听互联网业界前辈的见解，得窥行业秘辛。 钢总是个酷劲十足而又不失风趣的技术达人兼霸道总裁。有句话叫做，无形装逼最为致命。用在钢总身上最为贴切，境界确实不一样。钢总技术出身，在WPS呆了十年，公司里面一有难题就会找他，实力过硬。按他的说法就是，大大小小技术领域都玩过了。后来在金山跟雷军聊创业理念后，他决定出来创业，也就有了今天的中科云华。不过我比较感兴趣的是，他在金山时跟雷军、傅盛叫板时候的不羁与洒脱。这要是我的话，可能话都说不利索。 刀哥是个很沉稳的人，说话慢条斯理、逻辑清晰，不愧技术出身又成功转型为生意人。关于金融，刀哥有着自己的一套见解，认为未来的金融应该是一个标准化的市场，标准化交易。关于学习能力，刀哥认识是，一种能够在短时间内迅速掌理清新领域主要框架的能力。刀哥还给我们讲了他的年少轻狂，大学未毕业就带着基友跑到上海出来创业。当然这也不是主要的。那晚最让我记忆犹新的一句话是，刀哥拒绝雷军的挽留时讲的，“我要当的是老大，你给不了我”。 我曾经想过一个问题，怎样的人会在无形中让别人信服？ 现在我想给出一个答案，野心。这是我从身边有所成的人身上可以看到的。追求技术巅峰的野心，想要扬名立万的野心，想要建立起一个商业帝国的野心，想要改变生活的野心，乃至于要颠覆这个星球的野心。目标驱动主义，不达目标不罢休，不到棺材不落泪，甚至是置之死地而后生。突破现有的自己，想要紧紧握住通往梦想的门票。这就是野心。而这也是很难在一个大学生身上看到的，难能可贵的。 作为大学生，我很难能够从身边同学的眼中看到渴望，看到野心，更多的反而是一种萎靡，通宵打LOL的疲倦，无所事事的宅，无所适从的迷茫。时光，在他们身上变成了荒土。每一个能够进入大学的学生，都曾经是不一般的人，都怀着梦想踏进校门的。但是大学没有给到他们想要的，没有教给他们独立的能力，前瞻的眼光，明确的目标，深刻的野心，反而丢弃了用十几年义务教育才养成的学习能力。 肖老师说过，做科研只能是那些懂得精神满足的人才能做成功，比如一生都在say no的佩雷尔曼。因为只有在精神满足的情况下，你才能够全神贯注的进入到科研的领域中去。而对于野心，我认为正好相反，只有那些饥渴的人才能够拥有，因为精神上的饥渴，让他们极其渴望拥有，并且无从选择的去拥有，这就是野心。而这也是常人罕见的体验，常人只会甘于满足，认为，自讨苦吃的，不值得。没有人甘于平庸，但是，以大多数人努力的程度，注定平庸。 已经大三下，对于这几年的大学生涯，虽有遗憾，但却是实实在在的充实，我感谢自己的努力。但是，平常的忙里忙外，却鲜少有所成就，甚至有时候都是在瞎忙，回首也不知道自己在忙些什么。或许，说白了，自己确实是没有野心，没有极其渴望得到某样东西的欲望，随遇则安，得过且过。这不行，得治。 往者不可谏，来者犹可追。过去难以改变，也不需要改变，那就去改变未来吧。我不知道自己有一天会不会有颠覆世界的野心，也不知道自己能不能够改变这个世界。我只希望在我的每一个人生阶段，都能够有一个不一般的目标，一个小野心，跳出身边的圈子，找到更大的世界。","link":"/2022/07/24/2016-03-31-Ambition/"},{"title":"No Compromise","text":"昨天又是翘了一节课，而这次翘课又与往常稍微不一样，因为这是翘了中南的课，却到了湖大的课堂听讲。有时候觉得蛮有趣的，因为这是交了一份大学学费，上了两所大学。 昨天的课叫做，这个校友有点6，官方名字是“熊晓鸽奖学金、奖教金、我最敬爱的老师”颁奖仪式。 我跟几个同学早早来到了会场，坐到了前排。我是认真听完了全程，并随着掌声不自禁的喝彩，仿佛自身便是一名湖大人，能够感受到湖大的激情以及熊晓鸽熊先生的感召力之强。 全程中，有几个人我是格外印象深刻。一个是那位头发花白但面容依旧俊朗的主持人老师。开始是因为他充满磁性的嗓音以及沉稳的主持风格，后来是对于他在台下认真仔细准备主持词时候的敬佩。他身着中山装，身上还有着老一辈人的沉稳执着。 第二个是湖大的新任校长段校长。这个关注他的点就是，纯粹的，他能够听得到湖大学生的心声，保证不会断网断电，能够提前对来场嘉宾做好功课，以及能够抓住一切能够与学生交流的机会上台解答学生的问题。是个好校长。 最后一个当然就是主角熊晓鸽了。在昨天之前我也是不了解熊晓鸽是为何人物。于是专门去收集了下他的履历。然后，就只剩下跪舔了。 熊先生现任IDG（美国国际数据集团）全球常务副总裁兼亚洲区总裁，是IDG资本创始合伙人，被誉为中国引入高科技产业风险基金的第一人，曾投资过百度、腾讯、携程、当当、搜狐、哔哩哔哩等等四百多家公司，一个人掌握着10亿投资资金。然而熊先生却也是平困出身，年少是当过电工，后考上湖大，开始求学生涯，在湖大读书期间最喜欢的是晚上跑到岳麓山上思考。在新华社实习时候，梦想新华社外派战地记者。获得恩师推荐，来到波士顿大学，只用了八个月夺得新闻传播学院硕士学位。接着进入塔夫茨大学弗莱彻法律与外交学院攻读国际经济与商理博士学位。 台上的熊先生，没有所谓的威严，比较亲和，比较风趣，而且比较坑队友。因为正值移动互联网岳麓峰会，于是他邀请了湖湘会的朋友过来，包括58公司董事长姚劲波、拓维信息集团总裁李宇新等等。然后，然后就是一堆段子手的主场了，期间不乏掌声雷动。熊先生真是热爱着他的母校，就那一会，湖大就又有了至少一千多万的捐款，而且把这个熊晓鸽奖学金的含金量蹭蹭的给往上提高了许多，各位大佬都给予了应允。 这次课切切实实的给我证明了名校的价值所在——名校资源。这个资源不仅仅是说，你在学校课程上的教学资源，而是你整个职业生涯里面的社会资源。每一个校园都是一个圈子，维系这个圈子的是情怀、校友情怀，圈子里面的人相互关照，圈子外的人很难介入，比如耶鲁大学的骷髅会。所以，在学校里面是，有着满满的机会的。另外，名校与职工技校的区别在于，他不是技能培训机构，他培养的是思维，更是一种与世界平齐的视界，因为你面对的都是来自各个领域顶端的人物。可惜，国内高校并没有把这方面做的很好。 更加可惜的是，作为学生，还处于职业生涯的规划状态，缘由怯懦，总是对这些机会视若无睹。每当遇到这样的讲座，学校都只能是强制地让几个班的同学去充当水军了，因为学生对于这些所谓的大佬成功人士，是没有概念的，认为是与自己遥不可及的，觉得自己还是个学生，还是个孩子，还不需要考虑这些事情，他们是谁管我鸟事。校园的象牙塔里面，他们是安逸的，还没有意识到没个几年就要毕业，即将要面对这些柴米油盐酱醋茶。毕业不可怕，迷茫不可怕，选择也不可怕，可怕的是，在不知不觉之间，变得别无选择，在迷迷糊糊的时候，做出了最坏的选择而不自知，最后只能将就。 这几年，我也是常常做项目，也跟着别人到处跑，自己越来越清楚的感受到，技术不是生活的全部。人与计算机打交道，说到底还是简单直接的，因为计算机是不会欺骗，他对你是永远正直的。而人与人之间的门道，却是不可捉摸的，没有原理可言，没有所谓的定律可以依据。在计算机的01之间，或许程序员便是上帝，但是在这个社会框架里面，站在顶端主导世界变革的却永远不会是一个只知道01的人。所以，一直认为无形中便能够让人信服的人十分令人敬佩。 看着台上刚从美国波士顿飞回来的学姐，讲着她对晓鸽学长知遇之情的感激，我开着玩笑对旁边的同学说，“过不了十年，站在上面讲的人的就是你了”。他说好。 这是一篇反思文，凑合着看吧。​","link":"/2022/07/24/2016-04-02-No-Compromise/"},{"title":"Broadcast Receiver on Android","text":"前言Broadcast Receiver是Android组件中最基本也是最为常见用的四大组件之一。 Broadcast Receiver，广播接收者，顾名思义，是用来接收来自系统和应用中的广播。这种组件本质上是一种全局的监听器，用于监听系统全局的广播消息。 目录 Broadcast Receiver的生命周期 Broadcast的类型 Broadcast Receiver的注册方式 Broadcast Receiver的使用步骤 一、Broadcast Receiver的生命周期BroadcastReceiver 有一个回调方法：void onReceive(Context curContext, Intent broadcastMsg)。当一个广播消息到达接收者时，Android 调用它的 onReceive() 方法并传递给它包含消息的 Intent 对象。BroadcastReceiver 被认为仅当它执行这个方法时是活跃的。当 onReceive() 返回后，它是不活跃的。 Android系统的很多消息(如系统启动,新短信,来电话等)都通过BroadcastReceiver来分发。BroadcastReceiver的生命周期是短暂的，而且是消息一到达则创建执行完毕就立刻销毁的。 拥有一个活跃状态的广播接收器的进程被保护起来而不会被杀死，但仅拥有失活状态组件的进程则会在其它进程需要它所占有的内存的时候随时被杀掉。 所以，如果响应一个广播信息需要很长的一段时 间，我们一般会将其纳入一个衍生的线程中去完成，而不是在主线程内完成它，从而保证用户交互过程的流畅。 这带来一个问题，当一个广播消息的响应时费时的，因此应该在独立的线程中做这些事，远离用户界面或者其它组件运行的主线程。如果 onReceive() 衍生线程然后返回，整个进程，包括新的线程，被判定为不活跃的（除非进程中的其它应用程序组件是活跃的），否则将使它处于被杀的危机。解决这个问题的方法是 onReceive() 启动一个 Service，让 Service 做这个工作，因此系统知道进程中有活跃的工作在做。 通常某个应用或系统本身在某些事件（电池电量不足、来电来短信）来临时会广播一个 Intent 出去，通过注册一个 BroadcastReceiver 来监听到这些 Intent，并获取其中广播的数据。 二、Broadcast的类型Broadcast的类型有两种：普通广播和有序广播。 Normal broadcasts（普通广播）：Normal broadcasts是完全异步的可以同一时间被所有的接收者接收到。通常每个接收者都无需等待即可以接收到广播，接收者相互之间不会有影响。消息的传递效率比较高。但缺点是接收者不能讲接收的消息的处理信息传递给下一个接收者也不能停止消息的传播。 Ordered broadcasts（有序广播）：Ordered broadcasts的接收者按照一定的优先级进行消息的接收。如：A,B,C的优先级依次降低，那么消息先传递给A，在传递给B，最后传递给C。优先级别声明在中，取值为[-1000,1000]数值越大优先级别越高。优先级也可通过filter.setPriority(10)方式设置。 另外Ordered broadcasts的接收者可以通过abortBroadcast()的方式取消广播的传播，也可以通过setResultData和setResultExtras方法将处理的结果存入到Broadcast中，传递给下一个接收者。然后，下一个接收者通过getResultData()和getResultExtras(true)接收高优先级的接收者存入的数据。 三、Broadcast Receiver的注册方式注册有两种方式： 1、静态注册：这种方法是在配置AndroidManifest.xml配置文件中的application里面定义receiver并设置要接收的action。通过这种方式注册的广播为常驻型广播，也就是说如果应用程序关闭了，有相应事件触发，程序还是会被系统自动调用运行。如： 1234567&lt;!-- 在配置文件中注册BroadcastReceiver能够匹配的Intent --&gt;&lt;receiver android:name=&quot;com.example.test.MyBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;/action&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 2、动态注册：这种方法是通过代码在.Java文件中进行注册。通过这种方式注册的广播为非常驻型广播，即它会跟随Activity的生命周期，所以在Activity结束前我们需要调用unregisterReceiver(receiver)方法移除它，否则会报异常。 123456//通过代码的方式动态注册MyBroadcastReceiverMyBroadcastReceiver receiver=new MyBroadcastReceiver();IntentFilter filter=new IntentFilter();filter.addAction(&quot;android.intent.action.MyBroadcastReceiver&quot;);//注册receiverregisterReceiver(receiver, filter); 要接收某些action，需要在AndroidManifest.xml里面添加相应的permission。 四、Broadcast Receiver的使用步骤1、创建BroadcastReceiver的子类 由于BroadcastReceiver本质上是一种监听器，所以创建BroadcastReceiver的方法也非常简单，只需要创建一个BroadcastReceiver的子类然后重写onReceive (Context context, Intentintent)方法即可。 2、注册BroadcastReceiver 一旦实现了BroadcastReceiver，接下就应该指定该BroadcastReceiver能匹配的Intent即注册BroadcastReceiver。 另外，这是发送广播的代码： 123​Intent intent = new Intent(String action);intent.setAction(String action);sendBroadcast(Intent);","link":"/2022/07/24/2016-04-04-Android-BroadcastReceiver/"},{"title":"Content Provider on Android","text":"前言Content Provider是Android组件中最基本也是最为常见用的四大组件之一。 主要用于对外共享数据，也就是通过Content Provider把应用中的数据共享给其他应用访问，其他应用可以通过Content Provider对指定应用中的数据进行操作。Content Provider分为系统的和自定义的，系统的也就是例如联系人，图片等数据。 Android中对数据操作包含有： file, sqlite3, SharedPreferences, ContectResolver与ContentProvider。前三种数据操作方式都只是针对本应用内数据，程序不能通过这三种方法去操作别的应用内的数据。Android中提供ContectResolver与ContentProvider来操作别的应用程序的数据。 使用方式： 一个应用实现ContentProvider来提供内容给别的应用来操作 一个应用通过ContentResolver来操作别的应用数据，当然在自己的应用中也可以。 以下这段是Google Doc中对ContentProvider的大致概述： 内容提供者将一些特定的应用程序数据供给其它应用程序使用。内容提供者继承于Content Provider基类，为其它应用程序取用和存储它管理的数据实现了一套标准方法。然而，应用程序并不直接调用这些方法，而是使用一个 ContentResolver对象，调用它的方法作为替代。ContentResolver可以与任意内容提供者进行会话，与其合作来对所有相关交互通讯进行管理。 目录 为什么使用Content Provider？ Content Provider的关键类 ContentProvider的使用 监听ContentProvider中数据的变化 一、为什么使用Content Provider？关于数据共享，以前我们学习过文件操作模式，知道通过指定文件的操作模式为Context.MODE_WORLD_READABLE或Context.MODE_WORLD_WRITEABLE同样也可以对外共享数据。那么，这里为何要使用ContentProvider对外共享数据呢？ 是这样的，如果采用文件操作模式对外共享数据，数据的访问方式会因数据存储的方式而不同，导致数据的访问方式无法统一，如：采用xml文件对外共享数据，需要进行xml解析才能读取数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读取数据。 使用ContentProvider对外共享数据的好处是统一了数据的访问方式。 二、Content Provider的关键类1、ContentProvider Android提供了一些主要数据类型的ContentProvider，比如音频、视频、图片和私人通讯录等。可在android.provider包下面找到一些Android提供的ContentProvider。通过获得这些ContentProvider可以查询它们包含的数据，当然前提是已获得适当的读取权限。 主要方法： 123456public boolean onCreate() 在创建ContentProvider时调用；public Cursor query(Uri, String[], String, String[], String) 用于查询指定Uri的ContentProvider，返回一个Cursor；public Uri insert(Uri, ContentValues) 用于添加数据到指定Uri的ContentProvider中；public int update(Uri, ContentValues, String, String[]) 用于更新指定Uri的ContentProvider中的数据；public int delete(Uri, String, String[]) 用于从指定Uri的ContentProvider中删除数据；public String getType(Uri) 用于返回指定的Uri中的数据的MIME类型。 public String getType(Uri) 用于返回指定的Uri中的数据的MIME类型 1）如果操作的数据属于集合类型，那么MIME类型字符串应该以vnd.android.cursor.dir/开头。 例如：要得到所有person记录的Uri为content://contacts/person，那么返回的MIME类型字符串为”vnd.android.cursor.dir/person”。 2）如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头。 例如：要得到id为10的person记录的Uri为content://contacts/person/10，那么返回的MIME类型字符串应为”vnd.android.cursor.item/person”。 2、ContentResolver 当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Context提供的getContentResolver()方法。 ContentResolver cr = getContentResolver(); ContentResolver提供的方法和ContentProvider提供的方法对应的有以下几个方法。 1234public Uri insert(Uri uri, ContentValues values) 用于添加数据到指定Uri的ContentProvider中；public int delete(Uri uri, String selection, String[] selectionArgs) 用于从指定Uri的ContentProvider中删除数据；public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) 用于更新指定Uri的ContentProvider中的数据；public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 用于查询指定Uri的ContentProvider。 3、Uri解析类 Uri指定了将要操作的ContentProvider，其实可以把一个Uri看作是一个网址，我们把Uri分为三部分： 第一部分是”content://“，可以看作是网址中的”http://“； 第二部分是主机名或authority，用于唯一标识这个ContentProvider，外部应用需要根据这个标识来找到它。可以看作是网址中的主机名，如”blog.csdn.net”； 第三部分是路径名，用来表示将要操作的数据。可以看作网址中细分的内容路径。 因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher和ContentUris 。 1）UriMatcher类用于匹配Uri。 1、把你需要匹配Uri路径全部给注册上 123456789101112//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码UriMatcher sMatcher = new UriMatcher(UriMatcher.NO_MATCH);sMatcher.addURI(&quot;com.cyw.provider.personprovider&quot;, &quot;person&quot;, 1);sMatcher.addURI(&quot;com.cyw.provider.personprovider&quot;, &quot;person/#&quot;, 2);//#号为通配符switch (sMatcher.match(Uri.parse(&quot;content://com.cyw.provider.personprovider/person/10&quot;))) { case 1 break; case 2 break; default://不匹配 break;} 2、使用sMatcher.match(uri)方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用addURI()方法传入的第三个参数​ 2）ContentUris类用于操作Uri路径后面的ID部分，它有两个比较实用的方法： 1、withAppendedId(uri, id)用于为路径加上ID部分： 123Uri uri = Uri.parse(&quot;content://com.cyw.provider.personprovider/person&quot;)Uri resultUri = ContentUris.withAppendedId(uri, 10); //生成后的Uri为：content://com.cyw.provider.personprovider/person/10 2、parseId(uri)方法用于从路径中获取ID部分： 12Uri uri = Uri.parse(&quot;content://com.cyw.provider.personprovider/person/10&quot;)long personid = ContentUris.parseId(uri);//获取的结果为:10 三、ContentProvider的使用1、需要继承ContentProvider并重写方法 2、需要在AndroidManifest.xml使用对该ContentProvider进行配置，为了能让其他应用找到该ContentProvider ，ContentProvider采用了authorities（主机名/域名）对它进行唯一标识，你可以把ContentProvider看作是一个网站，authorities 就是域名。​ 四、监听ContentProvider中数据的变化1、如果ContentProvider的访问者需要知道ContentProvider中的数据发生变化，可以在ContentProvider发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者，例子如下： 123456public class PersonContentProvider extends ContentProvider { public Uri insert(Uri uri, ContentValues values) { db.insert(&quot;person&quot;, &quot;personid&quot;, values); getContext().getContentResolver().notifyChange(uri, null); }} 2、如果ContentProvider的访问者需要得到数据变化通知，必须使用ContentObserver对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法： 12345678910getContentResolver().registerContentObserver(Uri.parse(&quot;content://com.cyw.providers.personprovider/person&quot;), true, new PersonObserver(new Handler()));public class PersonObserver extends ContentObserver{ public PersonObserver(Handler handler) { super(handler); } public void onChange(boolean selfChange) { //此处可以进行相应的业务处理 }}","link":"/2022/07/24/2016-04-04-Android-ContentProvider/"},{"title":"Service on Android","text":"前言Service是Android组件中最基本也是最为常见用的四大组件之一。 service可以在和多场合的应用中使用，比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放，比如检测SD卡上文件的变化，再或者在后台记录你地理信息位置的改变等等，总之服务嘛，总是藏在后头的。 Service是在一段不定的时间运行在后台，不和用户交互应用组件。每个Service必须在manifest中通过来声明。可以通过contect.startservice和contect.bindserverice来启动。 Service和其他的应用组件一样，运行在进程的主线程中。这就是说如果service需要很多耗时或者阻塞的操作，需要在其子线程中实现。 目录 Service的生命周期及启动模式 Service的分类 Service与Thread的区别 Service的优先级 一、Service的生命周期及启动模式 1、使用context.startService() 启动Service是会会经历：context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service runningcontext.stopService() -&gt;onDestroy() -&gt;Service stop startService的时候，如果Service还没有运行，则android先调用onCreate()然后调用onStart()；如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。 stopService的时候，直接onDestroy，如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。 2、使用使用context.bindService()启动Service会经历：context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service runningonUnbind() -&gt; onDestroy() -&gt;Service stop onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候把调用者（Context，例如Activity）会和Service绑定在一起，Context退出了，Srevice就会调用onUnbind-&gt;onDestroy相应退出。 所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。 3、被启动startService又被绑定bindService的服务的生命周期：如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。 此时，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止； 4、启动service，根据onStartCommand的返回值不同，有两个附加的模式：1)START_STICKY 用于显示启动和停止service。2)START_NOT_STICKY或START_REDELIVER_INTENT用于有命令需要处理时才运行的模式。 startService与bindService的区别：1、使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。 如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。 采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。 2、使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。 采用Context.bindService()方法启动服务时只能调用onUnbind()方法解除调用者与服务解除，服务结束时会调用onDestroy()方法。 在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService? 1、如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。 2、如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService . 1)broadcast 的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行） 2)bindService 则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。 3、如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。 另外注意的是，当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同。 二、Service的分类按运行地点分类： 其实remote服务还是很少见的，并且一般都是系统服务。 按运行类型分类： 有同学可能会问，后台服务我们可以自己创建 ONGOING 的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground （ android 2.0 及其以后版本 ）或 setForeground （android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification 任然会移除掉。 按使用方式分类： 三、Service与Thread的区别很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面来解释一下。 1、Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。 2、Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！ 既然这样，那么为什么要用 Service 呢？ 其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一Thread 进行控制。 举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它。你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 四、Service的优先级拥有service的进程具有较高的优先级。只要在该service已经被启动(start)或者客户端连接(bindService)到它，Android系统会尽量保持拥有service的进程运行。当内存不足时，需要保持拥有service的进程。 1、如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。 2、如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed. 3、如果客户端已经连接到service(bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。 4、如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，不会在内存不足时killed。 5、如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。","link":"/2022/07/24/2016-04-04-Android-Service/"},{"title":"不只是三面","text":"前天，5月6号收到腾讯offer通知的时候，感到终于松了一口气。为了这个offer我也是跑了不少地方了，也可以很清晰的看得到这一两年来的变化。两个月的风尘，也可以暂时停下了。 回顾这次的能够得到腾讯的offer，我只有一句话可以总结： 这个offer，不只是只有三面。 缘由关于腾讯，我是面过了好多次了，不管是内推，还是说正常流程，都有参与过，但是那时候还是初出茅庐，对于面试还是不得要领，一直弄得很是不顺。心中虽有不甘，但是，却也没有想过说放弃任何一次机会。尤其是大三下了，虽说已经有了offer在身，却还是想要去尝试一番。 于是，当森然给我提及到，这次腾讯在找长沙站实习生招聘的志愿者的时候，我立马给腾讯这次长沙站的HR发了个邮件自荐。恰好，仿佛是命运眷顾，这位HR正是，我去年大二的时候，也是差不多这个时候腾讯霸面时候认识的中南的学长，那时候他是刚进入腾讯帮忙招聘。那时候虽然霸面没成功（其实霸面确实比正常流程的难，不过不失是一次机会），但是最大的收获是认识了学长满哥。就这样，我成了这次长沙站的志愿者。 而后，便又给学长投了一份简历。 真的很感谢满哥，真的很热心，因为不知道是什么原因，我的简历被卡在了内推二面环节，当时的面试官没有释放我的简历，导致我无法进行正常流程，霸面也不行，而感谢满哥能够不厌其烦的为我跟那个面试官沟通，释放简历，给了我一次、也是实习生招聘的最后一次面试机会。很是宝贵。 初试因为我是志愿者，在长沙站的这一周的招聘里面，我是有工作需要做的，没有多少时间准备。不过庆幸的是，以前的面试经验给了我很大的帮助，而且在工作之余，我热心的跟来面试来霸面的同学交流搭讪，能够感觉到大家都是很厉害的人，也能够更加体会到，作为面试官，作为一家公司，他们需要的会是一位怎样的员工。 那是第一天招聘的下午，轮到我去面试了。换班、上楼。很奇怪，没有很紧张，估计是在此之前了解的比较清楚了，舌头也说开了吧。具体面试的问题不是太记得清楚了。但是记得面试官问的大多是我的项目的问题，自己也对项目做足了功课的，所以没有太难。不过，面的时间有点短，感觉没有尽情的展示了自己的清楚，所以对结果有点紧张。之后在志愿者工作的时候，我又几次遇到初试官下来拿简历或是拿饭，很开心，便跟他搭上话来。其实面试官真的很好说话的。 当天晚上，没有收到通知，状态也没有变化。 次日下午，再次刷微信查询的时候，终于状态变成了复试，自己一个人在走道上跟疯了似的，又蹦又跳的。 复试收到复试通知后，当晚，我开始有点像高考复习一样，复习我所知道的知识点，尤其是数据结构中的树、图，算法导论中的排序、查找、分治、动态规划等等，博客（写博客真的是很重要，不论是在复习的时候，还是在面试的时候，因为面试的时候你可以直接展示给面试官你的成果，当然，你也要熟悉才行，最好是原创的），JVM等等。 我有做笔记的习惯，在以前的面试的时候，我还专门列了下自己所能够展示的知识点、加分项。所以，这次的复试准备的算是很充足了。 但是，剧情确实曲折的，我没想到的是，在一开始复试官便给了我一道完全没有思考过的问题（也是自己作死，在自我介绍的时候给自己挖了个坑）：C原因中，相同的Int，一个赋值为0，一个赋值为500，这两个Int有什么区别。这个真是没有回答的很好，但是，我说了下自己的理解。 之后，给了我一道题，手写代码。这道题的思路是很简单的一道需要排序的二分查找。虽然简单，但花了点时间，想用归并排序，出了问题。这也是我这次面试觉得最大的遗憾的地方。 这个时候了，我是有点方了。面试官人很好，也没有问多少我的技术方卖弄的问题了。开始问我，为什么选择腾讯，为什么想要做这个岗位，有什么想要问他的这样的问题。 虽然已经知道这位复试官面试的时候大多在20分钟左右，但没想到这么快就抛出了这个问题，我心想这是要悬。所以，在回答之后的这些问题的时候，我努力表现自己的诚意，也表现出自己在腾讯之后的职业发展，自己的目标明确，这几年的经历以及努力。最后又表示自己对这次面试的态度，说，自己对这次面试是不满意的，不管是第一个问题，还是拿到手写代码，都不是自己满意的，说自己一直在写《剑指offer》的试题，并上传到了自己的github上面了，也在经营分享自己的微信公众号。 复试官显然是感受到了我的执着。于是看了下我的初试官的评语，提了到我的初试官也问过的问题，也是我写过的一篇博客探讨过的问题——Android 的热修复方案。一道题，仿佛找到突破口一般，我开始沿着我的思路，把Android热修复的四大方案讲完，有发散到JVM以及GC算法上面了，思路清晰，有条有理。 还没等讲完，复试官便直接给了我通过的回复。真的，我整个人是飘着下来的，一直怀疑自己是不是听错了。因为我能够感觉到自己这么久来的努力在被肯定了。一扫前几天来的不顺。 当晚，我的状态变成了HR面。 HR面虽说，HR面是不怎么刷人了，但是鉴于武汉站的时候，那么多的HR面被刷的前车之鉴，我还是google了下，仔细准备HR面。其实也不是很知道如何准备，主要是需要放松心态，把HR当做是同事朋友，大家坐在一起聊一聊自己的经历看法见解。 这次是涛哥面我，因为之前在志愿者工作的时候，便与涛哥坐在一起吃过饭，了解到涛哥是一个很会聊天的人，所以，不是很紧张。跟涛哥聊得很开心，而且之后我发现，我的面试估计都可以称之为典范了吧，因为所有要问的问题我都被问了，其他人没有被问的我也被问了。 这次HR面，我可以说也是知道是通过了的。 所以，当次日刷状态的时候，我的状态改变了。 但是这时，你还不能说稳了。因为这只是说你的面试过了而已，之后，关于通过者的信息会传回到腾讯总部你将要在的部门（大多是你复试官所在的部门），让部门经理审核。所以，还不能说稳了，因为之后没能得到offer的人也不是没有。 一周之后，我接到了腾讯打来的电话，确认offer，签约。 关于简历简历真是敲门砖，是HR认识到你的第一印象。所以，简历一定要排版好，该写的写上，不会的、不熟悉的、不是十分有分量的不要写。然后简历打印不要用硬纸板打印，使用普通的纸打印就行了。而面产品的，我的建议是，附上的材料不要太多，捡重要的附上，简洁明了，表达你自己的见解就行了。当然，材料在排版、色调方面最好也要注意。 关于霸面1、最好是停留在现场等待。虽说，腾讯招聘的时候，有专门的霸面区接收霸面简历，HR也让霸面的同学回去等待。但是综合我的所见，我发现最好还是停留在现场等待。因为HR哥哥姐姐也是过来人，都知道霸面是需要更多的勇气的，也理解霸面同学的焦急无奈的情绪，他们都是很好的人，也会想办法给你机会的。再者是，面试官面试速度是不一样的，一天的面试人数也是不一样的，有时面试官会下来拿霸面同学的简历，而在现场的同学更加有机会与面试官攀谈上，率先让他过目简历。 2、要灵活。关于霸面，也是需要动动脑筋的。不是说你在那儿等就行了，总会有机会的，机会也是需要争取的，运气也是需要脱颖而出的。相比于在现场傻傻等待面试机会的同学，我更加佩服的是那些不只是把眼光放于当前这场招聘的同学。一、你需要等待表现出诚意，也要表现在HR面前，让他们看到你的努力，最好是有机会能够与HR攀谈上，表现出你自己，与他们成为朋友，这是最好的结果，再不济也能够给他们留个眼熟啊。二、如果你不好意思与HR交流，毕竟还是有点尴尬的，你也可以与在场的面试的同学交流，了解了解你的对手都是一些什么样的人，大家对于面试的想法，面试官都面了什么，他们是怎么回答的，你又该怎么回答，自己有什么不足等等。而且面试现场真的也有好多的美女咧，交几个朋友总不是什么坏事。 3、当你觉得你已经足够勇敢的时候，其实你还需要更加的勇敢。这一点真是在霸面产品的同学身上体现的十分贴切啊。知道，面试现场的好多人都是专门从其他城市赶过来的，比如武汉、南昌、南宁，甚至是北京，很多的研究生，很多的在其他站HR面被拒的想要再抓住机会的同学，大家都是十分的努力，也是足够的勇敢的。但有时候，结果不是单单的努力就会有结果的，运气也不会一直眷顾你。这个时候，你就需要比那些好运的实力更强的又足够勇敢的变得更加勇敢才行。这次长沙站守电梯，送面试者上去面试的人是我。很多人跑来跟我说，帮忙刷他们上去，给他们一个机会。因为职责所在，没有答应。但是人不能够死脑筋，总会有办法的。很多面产品的同学，还是找到了其他办法，没有经过我，刷上去了面试官的楼层。虽然结果不是很理想，但是这是勇敢给他们制造的又多的一个机会。当然，我不是很推荐这种做法就是了，但是也是看不同面试官的。 4、凡事有个度。霸面是一种勇气的表现，但是需要一个度。也是这次长沙站，有个同学就多次想办法上去直接找面试官。我不知道结果如何，但是如果我是面试官，我也会觉得有点厌烦的。因为招聘就像相亲，看顺眼了，适合了自然而然就会成，自然而然就会过，不必太过于纠缠。还有就是，在霸面的过程中要有礼貌，遵守流程，不要无理取闹，听取工作人员的建议以及警惕工作人员的警告。腾讯是有一个黑名单的，无视警告的都会被计入黑名单之中。 关于面试面经永远是别人的面经，最好的办法是自己亲临战场去经历去成长。在面试的时候，展示你的所能，坦然真诚坚持富有激情拥有潜力。 后记最后，真的是感谢森然，感谢满哥，也感谢一起志愿服务的朋友们，也感谢自己的坚持。面试了这么多次，这次是第一次走完整个流程的，以前也没有，以前得到的offer也都是直接跟老大聊聊就成了的。整个流程下来，真的成长了不少，也涨了见识。这次是我距离腾讯offer最近的一次，还好我没有辜负满哥的期待。 谨以此文，记录此刻。","link":"/2022/07/24/2016-05-08-Tencent-Offer/"},{"title":"GC","text":"今天，我们来探讨一下JVM里面的GC算法吧，这也是JAVA用户所不能避开的问题。 JAVA相比之C++的一大的区别是，JAVA能够基于JVM对内存进行自动的分配与释放，而不像C++一样需要工程师手动的注意各个变量的内存分配以及释放，时时刻刻得小心是否已经造成了内存泄漏这些问题，比较麻烦。 那么，到底会有哪几种GC算法呢？我们就按照一个时间层层递进的顺序来大致了解一下吧。 引用计数法引用计数法是最经典最古老的一种垃圾收集方法。 引用计数法的基本思路是：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就会+1，反之，当引用失效时，引用计数器就-1.只要对象A的引用计数器的值为0，则对象A就不可能在被使用，此时可以被回收了。 实现也是比较简单的，就是为每一个对象创建一个整型的计数器即可。但是，这个方法有个致命缺点，那就是它无法处理循环引用的问题。因此，JAVA的垃圾回收器中，没有采用这种算法。 而所谓的循环引用是，有两个对象A和B，A对象中含有B的引用，B对象含有A的引用，此时，A和B的引用计数器的值都不是0，但是在系统中，又没有第三个对象引用了A或B，此时，A和B应该是被回收的对象，是垃圾对象，但是由于垃圾对象之间相互引用，从而是垃圾回收器无法识别，引发内存泄漏。 标记-清除算法(Mark-Sweep)既然引用计数法有着缺陷，那么我们就换个思路，给每一个还存活的对象进行标记，而没有标记的就是垃圾对象，这样就很方便于垃圾回收器回收清除垃圾对象了。也就是说，标记-清除算法将垃圾回收分为标记、清除两个阶段。 其基本思路是：在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。然后在清除阶段，清除所有未被标记的对象。 但是，标记-清除算法最大的问题是内存空间碎片化的问题。回收后的内存空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的效率要低于连续的空间。 复制算法复制算法，算是从标记-清除算法中演变而来的一种算法。 首先，我们知道现在JVM中的JAVA堆大体分为三个区，分别是年轻代（YYoung Generation）、年老代（Old Generation），以及持久代（Permanent Generation）。在年轻代中又有一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个）。而我们的复制算法便是使用在这两个Survivor区之间的。 接着，我们假定在这个年轻代中，只有两个Survivor区，每次只使用其中的一个Survivor区。好，那么我们把这两个Survivor区命名为S1和S2。假设这次只使用S1区。 在S1中使用标记-清除算法，对还存活的对象进行标记，然后将被标记的还存活的对象复制到S2中，最后清除S1中所有的对象。这样便做到了防止内存碎片化的情况发生。 那么总结一下，复制算法的基本思路是：将原有的内存空间分为两块，每次只使用其中的一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未使用的内存块之中，之后清除正在使用的内存块中的所有对象。然后交换两个内存块的角色，完成垃圾回收。 优点是： 1、高效。在系统中垃圾对象较多的时候，也就是真正需要垃圾回收的时候，复制算法需要复制的存活对象并不多，所以复制算法的效率很高。 2、确保回收后的内存空间没有碎片。 缺点是，需要将系统的内存空间折半。 另外，在垃圾回收的时候，eden空间中的存活对象会被复制到未使用的survivor空间中，正在使用的survivor空间中的年轻对象也会被复制到未使用的survivor中（大对象，或者年老对象会直接进入年老代，如果未使用的survivor空间已满，则对象也会直接进入年老代）。 标记-压缩算法(Mark-Compact)我们知道，复制算法的高效性是建立在存活对象少、垃圾对象很多的前提下。这种情况在年轻代是经常发生的，但是在年老代，更常见的是大部分对象是存活对象，如果依然使用复制算法的话，由于存活对象较多，复制成本便变得很大。 而标记-压缩算法正是一种年老代的回收算法。 标记-压缩算法是在标记-清除算法上进行改进过后的算法。基本思路是：首先跟标记-清除算法一样，需要从根结点开始，对所有可达的对象进行标记，之后，不是简单的清除，而是将所有的存活对象压缩到内存的一端，接着才是清除边界以外的所有的内存空间。 这样，既避免了内存的碎片化，也不需要两块相同的内存空间。性价比较高。 增量算法增量算法是专门对垃圾回收时Stop the World状态的一种优化算法。 对于大部分的垃圾回收算法来说，在垃圾回收的过程中，软件会处于一种Stop the World 的状态。在这个状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很长时间，将会严重影响用户体验和系统的稳定性。 而增量算法的基本思路是：如果一次性的将所有的垃圾进行处理，需要造成系统长时间的停顿暂停，那么可以让垃圾收集线程和应用程序线程交替执行。这样，每次垃圾回收只收集一小片区域的内存空间，接着又切换到应用程序线程。以此反复，知道垃圾回收完成。这样，便可以减少系统的停顿时间。 缺点是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 后记这些便是一些简单的GC算法了。如若有错，还请斧正。多谢。","link":"/2022/07/24/2016-05-16-GC/"},{"title":"大鱼·海棠","text":"2016年7月8日，期待已久的《大鱼·海棠》终于上映了。然而，这部中国唯美动画电影的本土化尝试，却引起网民的撕逼大战。有的认为这是12年等待的落空，有的认为中国动漫的崛起又要往后延了一年，在某乎上黑《大鱼·海棠》更是成为了政治正确的选择。 而因为疲于工作的Yale我，今天终于抽出时间毫不犹豫掏出口袋里仅有的几个钢镚买了电影票，圆了我整整6年的期待。 可以说，《大鱼·海棠》是继《宝莲灯》以来代表着中国最高实力的国产动画电影，对，我封的，也包括《大圣归来》。因为《大圣归来》更多是依赖于齐天大圣孙悟空这一国民英雄，而不是剧情等等，这是一个巨大的IP。 当初没有机会给《大鱼·海棠》众筹以期给国产动漫事业做贡献，那么，今天我就为她做一期推送，表达一下我的看法吧。 我是在高一的一次去网吧，看到的《大鱼·海棠》的。那时候看的是她最初版本的预告片，真是瞬间爆炸，一下子就被她唯美的画风、奇妙的想法所深深吸引。没错，就这样我成为了她的粉丝。 但是那时候毕竟还是个高中生，哪有时间上网，我可是个三好学生，高中学习压力大，根本没有时间去继续跟进《大·海》的情况，甚至都没有搞清楚为啥这个电影只有一个预告片正片到底在哪的问题。只是有时候在闲暇之余会想起这个惊艳我一时的《大·海》。 后来，来到了大学，学的是信息方面的专业，学会了上网，还特地去了解《大鱼·海棠》的状况，才解开了当年的困惑。虽然，时间漫长，但是我还是愿意去等待的。 一直很是佩服梁旋张春的勇气与洒脱，仅仅是因为一个梦，便不惜耗费12年的光阴去实现。这可是12年啊，还是真值青春年华啊。人生有几个12年，这不是说说就能够做得到的，期间的心酸坎坷也不是常人所能度之的。这是勇士之为。 也许，他们是幸运的，知道自己人来所为何事，油然而生的使命感令其不可不为，身先士卒。人生难得知己。在梁旋决定要为一个梦创办彼岸天，将其制作成电影时，张春不离不弃，投入全身尽力支持他。好基友一被子啊。 而这两人也没有让我失望，再加上我的偶像Eason为《大·海》献唱了《在这个世界相遇》，更是让我为制作方点赞。可以说，整部电影画面唯美，设定惊奇充满着中国风，细节处理的很到位（尤其是客家土楼、门窗纹理、人物考究）、配音流畅，在剧情方面，逻辑比较流畅，前期铺垫也做得很足，就是在湫向椿表白的时候，略显尴尬，但是毕竟是动画、人物设定也是十几岁的少年少女，情窦初开，很难说怎么处理才适合，这不难理解。我真的想不通为啥剧情会被大家所如此诟病。 虽然，我很想在剧情方面展开讨论，但是秉着剧透一时爽的原则，便在此不表。在画风方面，有人说很像《千与千寻》，或者是说抄袭《千与千寻》，但是我说，说像《千与千寻》，那是谬赞，毕竟能够拿来与异步世界级的作品进行对比，是《大·海》的荣幸啊，说明这中国动漫的进步，但是说是抄袭的，我就只能怀疑这个人的智商了，到底是哪里抄了。不管是剧情方面、画风方面、设定方面，真是一毛钱都扯不上啊。 整个电影，处处充满着良心，考究、考究、真是十分的考究。我认为，不失为一部佳作。这部作品，我们虽不能说国漫崛起，但是可以清晰的看出来，我们在进步。这是一次很好的经验。尽管现在国产动漫圈很小，但是在这一次又一次的尝试之后，积累经验、吸引培育人才，我们定能培育出真正能够做到国漫崛起的沃土。 现如今，中国动漫产业正在不断的成长，不少投资人也在把目光投向这里，加上东家腾讯、B站、A站、有妖气等等公司的大力支持，涌现出不少好的作品，比如动漫堂米二的《一人之下》、夏天岛的《狐妖小红娘》、老壁的《端脑》等等，而中国特色的动画产业商业模式也在逐渐的形成，产业链也在艰辛地构筑当中。我也算是看动漫看了十多年的人了吧，经历过《漫画世界》、《知音漫客》、《龙漫》、有妖气等等的兴落，听说更加之前的时候国漫更是一片死寂。所以，这真是一个很棒的时代。或许，现在还不如人意，但是这是一个曲折上升的过程，毕竟一口吃不出个大胖子，但是只要不放弃努力，国漫崛起不是梦。","link":"/2022/07/24/2016-07-17-bigfishbegonia/"},{"title":"大学者，蜕变之谓也","text":"总是有很多的借口给自己开脱不更公众号，慢慢的便会错过很多。 蓝杰游学已经过去了一个多周，近来才有时间总结，毕竟实习考核在即。很难得的有机会接触这么多的学弟学妹，发现现在蓝杰的人数真是暴涨，自己已然成为了其中的老字辈？！很多人都不认识了。看着这些年轻的面孔，这些手握着大学时光的大一大二生们，有点唏嘘，想起了自己当年的囧样，啥都不懂，屁颠屁颠的到处闹腾。 很敬佩胡哥，又做了件了不起的事情，竟想着带着六七十号人从长沙跑来深圳，让这帮初出茅庐的小子们见识何所谓互联网公司，见识见识这腾讯，这华为，这京东和深信服。仿佛每年都在实现一个小愿望。 自己还不是个人物，也不是很会讲些严肃的话题，所以分享的时候也只能给学弟学妹们打了个马虎眼，毕竟自己体会才是硬道理。不过要想说的话，我觉得，大学，就是个蜕变之地，没人知道你将会蜕变成什么样的巨龙。 一直很信奉的一句话是，“挣扎跳出自己的舒适区”。私以为，人只有觉得困惑不解、窘迫不安、不知所措、无所依靠的时候，才会想到成长，变强。因为那个时候，你的所学所得已经无法适应着变化的环境，你只得不断的学习新的知识，新的领域，新的技能来化解这燃眉之急。 大学就是个舒适区。中午起床，然后对着手机、看着电脑，就是撸个一天，抽空订个外卖便解决了一天的口活，偶尔老师点名了无奈就去教室里边，或是瞌睡，或是玩手机，或是想着某某院某某系某某班的妹子好好看，谈论着谁谁谁排位又上了黄金，下课了该吃什么啊附近都没什么新店了，作业是什么，大不了就是网上一抄，考试来了怎么办快快快去图书馆占个位子学一下，不行也显得自己有好好学习了，卧槽这题怎么这么难我玩会手机先压压惊，参加个什么活动啊还要睡觉呢除非有妹子，看到某某某又拿了全年第一国奖国励某某比赛金奖体育全能出国留学创业拿了好几百万的投资也不会有个什么波澜毕竟与自己远着呢。舒适的生活，没有一滴波澜，日复一日，仿佛时间就是用来挥霍的，只愿今日醉生梦死。 当初我为什么不在省内而跑到这么远的长沙读书，不就是图了个新鲜，不被家人给束缚在省内，无法见识这世界的奇妙，无法品味这多样的中华美食，无法体验着多彩的生活吗！那么这样的安逸生活，是自己想要的吗？不是。记得大一的时候，协会会长说过自己不想去自己母亲的事业单位，因为在那里他已经看到了自己老年的模样。突然就有点心惊。 所以我一直在变，为的只是将过去的自己给甩的远远地，为的是未来的很多很多的不一样的事物。 当然，每次见到老同学，他们都说我没变。确实，有所为有所不为，情义是不能变的。 可惜的是，自己挣扎跳出舒适区，到现在，还是有很多的地方没有改变，还是一样的不够果断，还是一样的不会吉他画画，还是一样的单身，还是一样的怯懦。幸运的是，我学会了编程，学会了独自生活，学会了独自旅行，学会了怎么快速与当地人聊天，学会了尝试，学会了记录，学会了挑战，还有庆幸认识了这么多的很棒的朋友。 大学者，蜕变之谓也。这几年里，我见识了有人从学渣到学霸的成长，立志科研的奋斗，为了追求爱情而形象的巨变，为了寻找而各地的旅行，为了汉服崛起的努力，为了梦想毅然奔赴边疆的军旅，为了出国深造的艰苦准备，为了世界第一而不惜耗光大学四年，为了青春而创业，为了改变而主持演话剧学轮滑跳舞画画学琴唱歌登台表演与人辩论编程。每个人都有欲望，都有梦想，都有自己喜欢的爱做的事情。不知道以后还有没有机会，但现在肯定是有机会的，所以趁这个机会不如得到蜕变，做一些自己以前想过没有想过的事情。这，才是青春。 未来，我还要认识更多不一样的人，见识更多好玩的事物，学习好多好多的好玩的，走遍青山绿水，跨越山河，要有诗，也要有远方。","link":"/2022/07/24/2016-08-21-disintegration/"},{"title":"扩展属性Extended Attributes","text":"目录 1. EA的概述 2. EA的命名空间 3. EA的Shell指令 4. EA的限制 4.1 对User EA的限制 4.2 EA实现上的限制 5. EA的系统调用 5.1 创建和修改EA 5.2 获取EA值 5.3 删除EA 5.4 获取文件相关的所有EA 1、EA的概述所谓扩展属性，Extended Attributes，以下简称EA，是区分于文件属性、文件的扩展出来的属性。 EA是目前流行的POSIX系统中文件系统具有的一项特殊功能，可以给文件、文件夹添加额外的key/value的键值对，可以以键值对地形式将任意元数据与文件i节点关联起来。键和值都是字符串并且有一定长度地限制，是完全自定义的属性。Linux自版本2.6起，开始支持EA。 我们可利用EA去实现访问列表和文件能力、记录文件地版本号、与文件地MIME类型/字符集有关的信息，或是指向图符的指针。 EA需要底层文件系统来支撑，包括btrfs、ext2、ext3、ext4、JFS、Reiserfs以及XFS等文件系统都支持EA。各类文件系统对EA的支持都属可选项，受内核配置选项中的“File systems”菜单控制。Reiserfs文件系统自Linux 2.6.7开始支持EA。 2、EA的命名空间 EA的命名格式是namespace.name。其中namespace是用来把EA从功能上划分为截然不同地几大类。而name是用来在指定命名空间内唯一标识某一EA。 可供namespace使用的值有4个：user、trusted、system以及security。这4类EA的用途可参考如下： User EA： 将在文件系统检查地制约下由非特权级进程操控。要想获取User EA值，需要由文件地读权限；要想改变User EA值，则需要写权限。若无所需权限，将会导致EACCES错误。 在ext2、ext3、ext4或Reiserfs文件系统上，如要将User EA与一文件关联，需要在装配底层文件系统时候带选上user_xattr选项。$ mount –o user_xattr device directory Trusted EA： 也可以由用户进程驱使，跟User EA类似。 与User EA的区别是，要操纵trusted EA，必须是特权进程。 System EA：供内核使用，将系统对象与一文件关联。目前仅支持访问控制列表。 Security EA： 用来存储服务于操作系统安全模块地文件安全标签； 将可执行文件与能力关联起来; 设计初衷是为了支持安全强化版地Linux（SELinux）。 一个i节点可以拥有多个相关EA，其所属地命名空间可以相同，也可不同。各个命名空间里，EA是自成一体的，即是说这些命名空间是互不排斥的。另外，在user和trusted命名空间内，EA名可以是任意字符串。在system内，只有经过内核明确认可地命名才可使用，比如访问控制列表。 3、EA的Shell指令 在Shell中，可执行setfattr(1)和getfattr(1)命令来设置和查看文件的EA。 1234567touchtfilesetfattr -n user.x -v &quot;The past is not dead.&quot; tfilegetfattr -n user.xtfilegetfattr -d tfile 另外需要注意的是，EA值可以为空字符串，这不同于未定义的EA值。 setfattr getfattr 默认情况下，getfattr只会列出User EA值。可利用-m选项指定一个正则表达式，来筛选要显示地EA名 1234567891011$ getfattr -m - tfile# file: tfileuser.x$ getfattr -m x tfile# file: tfileuser.x$ getfattr -m y tfile attr 这个shell指令涵盖了setfattr和getfattr的功能，是两者的集合。 4、EA的限制 1) 对User EA的限制 User EA只能施之于文件或目录，之所以将其他文件类型排除在外，原因如下： 1、因为符号链接会对所有用户开启所有权限，而且这是不可更改的。然而，对于User EA，是需要考虑权限地。这是相互矛盾地。如果使用符号链接，系统会吧链接去除掉。 2、对于设备文件、套接字以及FIFO而言，授予用户权限，意在对其针对底层对象所执行的i/o操作加以控制，如欲操控这些权限，转而求取对创建user EA地控制，二者会出现权限冲突。 3、若某一目录启用了粘性位（sticky位），且为其他用户所拥有，则非特权用户不能将一User EA置于该目录之上。惟其如此，才能防止任一用户将EA附于诸如/tmp之类的目录之上，由于其可写权限对所有用户开放，导致任意用户均可操纵此目录的EA，而设置粘性位，意在防止用户删除该目录下为其他用户所拥有的文件。 2)EA实现上的限制 1、EA名称地长度不能超过255个字节 2、EA值的容量为64KB 此外，某些文件系统对可与文件挂钩的EA数量及其大小还有更为严格的限制。 3、在ext2、ext3以及ext4文件系统上，与一文件关联地所有EA命名和EA值地总字节数不会超过单个逻辑磁盘块的大小：1024字节、2048字节或4096字节 4、在JFS上，为某一文件系统所使用的所有EA名和EA值地总字节数上限为128KB 5、EA的系统调用 1) 创建和修改EA 系统可调用以下方法来设置EA值。 setxattr:通过pathname来标识文件，如果文件名是符号链接，则对其解引用； lsetxattr:通过pathname来标识文件，如果文件名是符号链接，不会对其解引用； fsetxattr:通过打开文件描述符fd来标识文件。 以上3者之间的差异同样适用于本文下面介绍的其他各组系统调用。 参数name是一个以空字符串结尾地字符串，定义了EA地名称。 参数value是一个指向缓冲区地指针，包含了为EA定义地新值。 参数size是指明缓冲区地大小。 默认情况，指定名称地EA不存在，系统调用会创建一个新的EA。已经存在地话，就会进行替换。 参数flags是可对这一行为进行控制，将这参数指定为0，设定为默认情况。或者可将其指定为如下常量之一： 2) 获取EA值 可利用以下方法来获取EA值。 参数name是一个以空字符串结尾地字符串，定义了EA地名称。用来标识要取值地EA。 返回的EA值保存于参数value所指向地缓冲区中，该缓冲区必须由调用者分配，其大小由size来指定。若调用成功，会返回复制到value所指向地缓冲区中地字节数 若文件不含name的EA，系统调用失败，会返回错误ENODATA。 若size过小，系统调用也会失败，并返回错误ERANGE。 可设size为0，将会忽略value，系统调用仍会返回EA值地大小，可用来获取EA值所需value缓冲区大小。 3) 删除EA 可利用以下方法删除文件的EA。 Name所含以空字符串结尾的字符串，用于标识打算删除的EA。若试图删除不存在的EA，调用将失败，并会返回错误ENODATA。 4) 获取文件相关的所有EA 以下方法返回的列表会包含与某文件关联的所有EA的名称。 将EA地名称列表以一系列以空字符结尾地字符形式置于list所指向地缓冲区中。缓冲区大小由size指定。 与getxattr一样，可以将size指定为0，系统调用将忽略list，并返回后续调用实际获取EA名称列表时所需的缓冲区大小。 想要获取与某文件相关的EA列表，只需对文件拥有访问权限，对文件本身则无需任何权限。 处于安全堪虑，list中返回的EA名称可能不包含调用进程无权访问的属性名。比如，在非特权进程中调用listxattr()时，大多数文件系统都会忽略trusted EA。","link":"/2022/07/24/2016-08-22-EA/"},{"title":"Introduction to Leap Motion","text":"前言最近是要完成一个关于Leap Motion的项目，所以就顺便到官网翻译了下文章。一下首先是翻译的可以直接上手的Setting up a project，以及Hello World。 目录1.Setting up a project 2.Hello World 1.Setting up a projectLeap Motion java SDK 使用的封装了Leap Motion API 类定义的标准jar包，以及一系列的原生库(native libraries)，让你可以开发Leap的java程序，与Leap Motion进行数据交换。通常，创建一个java项目包含以下步骤：添加LeapJava.jar文件到你的项目的classpath文件中，设置JVM库路径参数以至于你的JVM能够找得到Leap Motion的原生库。 Leap Motion Java librariesLeap Motion的jar包是跨平台的，但是他的原生库必须要与系统平台以及用于执行程序的JVM的体系结构进行匹配。 为了能偶在Java程序中使用到Leap Motion的SDk，你需要添加LeapJava.jar文件到classpath文件中，然后设置java库的路径到Leap Motion原生库的位置。 需要使用到Leap Motion Java SDK的以下Java和原生库。 32-bit Windows: LeapSDK/lib/LeapJava.jar–Leap Motion Java API的类定义。 LeapSDk/lib/x86/LeapJava.dll–在Windows系统下的32-bit Leap Motion Java库。 LeapSDK/lib/x86/Leap.dll–在Windows系统下的32-bit Leap Motion库。 64-bit Windows: LeapSDK/lib/LeapJava.jar–Leap Motion Java API的类定义。 LeapSDK/lib/x64/LeapJava.dll–在Windows系统下的64-bit Leap Motion Java库。 LeapSDK/lib/x64/Leap.dll–在Windows系统下的64-bit Leap Motion库。 32- or 64-bit Mac OS: LeapSDK/lib/LeapJava.jar–Leap Motion Java API的类定义。 LeapSDK/lib/libLeapJava.sylib–Mac系统下的Leap Motion Java库。 LeapSDK/lib/libLeap.sylib–Mac系统下的Leap Motion库。 Compile from the command line使用java编译器，javac编译，设置classpath选项以指定LeapJar文件。举个例子，要编译包含在Leap Motion SDk中的Sample.java，你可以使用一下命令行： 1234javac -classpath &lt;LeapMotion&gt;/lib/LeapJava.jar Sample.java (是指你安装的Leap Motion SDK所在的文件夹) Run from the command line为了运行Leap驱动的程序，java在运行时需要找到Leap Motion原生本地库。LeapJava.jar必须已经设置在classpath文件里面了。你可以设置java的’java.library.path’参数以识别原生库。更关键的是，在Windows系统下，你必须制定32-bit 或者64-bit库以匹配你使用的JVM的体系架构。 在MAC上，你可以使用一下命令行运行’Sample’程序： 123java -classpath &quot;.:&lt;LeapSDK&gt;/lib/LeapJava.jar&quot; -Sjava.library.path=&lt;LeapSDK&gt;/lib Sample 在Windows下，你可以使用以下命令行在64-bit JVm下运行Sample程序： 1234java -classpath &quot;.;&lt;LeapSDK&gt;/lib/LeapJava.jar&quot; -Djava.library.path=&lt;LeapSDK&gt;/lib/x64 Sample Eclipse在eclipse IDE里，你要添加LeapJava.jar文件到项目工程中，作为一个外部jar包，然后设置正确的原生Leap Motion库的路径为Jar包的一个属性。 在Eclipse的文件菜单上选择New &gt; Java Project. 在Create Java Project页面上给项目工程指定一个名称，然后如必要的话设置其他属性(Leap Motion SDK支持Java 6和7) 点击Next键，进入Java Setting页面 选择Livbrary选项 点击*Add External Jars…*按钮 导航到LeapJava.jar包 点击Open键，添加LeapJava.jar到项目工程中 接着，在Library列表里面点击LeapJava.jar条目前面的小三角形，出现Library的属性 选择Native Library location条目 点击Edit按钮 导航到半酣Leap Motion原生库的文件夹 在Windows下，需要确保你要选择的文件夹下包含适合你的目标体系架构的正确的库。如果你的是32-bit JVM，要用SDk里面x86文件夹下的Leap Motion库。如果你的是64-bit JVM，要用SDk里面x64文件夹下的Leap Motion库。在Mac上，Leap Motion库支持任意体系架构。 点击OK设置路径 注意：或者你也可以通过项目属性对话框添加Leap Motion库到一个已经存在的项目工程之中。 IntelliJ在IntelliJ IDE上，你要添加LeapJava.jar文件到项目工程中作为一个库，需要分别使用JVM参数设置Leap Motion原生库的路径，’java.library.path’.JVM 参数可以通过使用IntelliJ Run/Debug组态来设置。 以下步骤添加LeapJava.jar到项目工程中： 按通常的方法创建了一个工程之后，选择File &gt; Project Structure菜单打开设置对话框 在project Setting下点击Library 点击在库列表顶部的小’+’号按钮，打开Select Library Files对话框 从你的Leap Motion SDK添加’LeapJava.jar’ 通过创建一个Run/Debug configuration来设置到原生Leap Motion库的路径： 选择Run &gt; Edit Configurations… 菜单 点击在配置离别上面的小’+’号按钮 选择应用，创建一个新的应用配置 指定一个名称 设置VM选项域来设置’-Djava.library.path’参数指向Leap Motion原生库所在的文件夹 点击OK 在Windows下，确保选择跟你的JVM体系匹配的文件夹。如果你的是32-bit JVM，要用SDk里面x86文件夹下的Leap Motion库。如果你的是64-bit JVM，要用SDk里面x64文件夹下的Leap Motion库。在Mac上，Leap Motion库支持任意体系架构。 NetBeans在NetBeans IDE下，你要添加LeapJava.jar文件到项目工程中作为一个库，需要分别使用JVM参数设置Leap Motion原生库的路径，’java.library.path’.JVM 参数可以通过使用IntelliJ Run/Debug组态来设置。 以下步骤添加LeapJava.jar到项目工程中： 按通常的方法创建了一个工程之后，选择File &gt; Project Properties菜单打开设置对话框 点击Library 点击Add Jar/Folder 按钮 在你的Leap Motion SDk中找到’LeapJava.jar’ 点击OK添加jar包到你的project中 接着，在你的项目属性列表中点击Run 设置VM选项域来设置’-Djava.library.path’参数指向Leap Motion原生库所在的文件夹 在Windows下，确保选择跟你的JVM体系匹配的文件夹。如果你的是32-bit JVM，要用SDk里面x86文件夹下的Leap Motion库。如果你的是64-bit JVM，要用SDk里面x64文件夹下的Leap Motion库。在Mac上，Leap Motion库支持任意体系架构。 2. Hello World这篇文章演示了如何连接Leap Motion控制器，还有基本的访问跟踪数据操作。在阅读完这篇文章之后以及紧随文章编写属于你自己的基本程序，你应该拥有了扎实的基础，可以开始你的应用开发之旅了。 首先，是一小段的背景知识… How the Leap Motion Controller WorksLeap Motion控制器着重的包括硬件和软件组件。 Leap Motion硬件主要包括一对立体声红外摄像机和照明LED的。摄像传感器朝上(当该装置处于其标准定向的时候)。下面的这个插图从Leap Motion传感器的视角来展示了一名用户的手。 Leap Motion软件接收来自传感器的数据，然后分析这个数据，尤其是手掌、手指、手臂，或者工具的数据(追踪其他类型的数据，可能会在将来添加对应的对象的，而这是当前能跟踪的实体)。软件保持着人手的内部模型，然后与传感器发送来的数据组成的模型进行比较，以决定最好的匹配样式。传感器数据将会一帧一帧的被分析，设备会传送每一帧的数据到你的Leap Motion驱动的应用里面。被你的应用接收到的’Frame’对象包含所有已知的位置，速度和跟踪实体的辨识。比如手掌，手指，还有工具。构造，比如说手势，和跨越多个帧的动作，都需要不断刷新每一帧。如果需要控制器提供的跟踪数据的概述的话，可以阅读API Overview。 Leap Motion软件可以在客户端计算机上作为一种服务(Windows)或者是一个守护线程(Mac和Linux)。原生的Leap Motion驱动的应用可以使用Leap Motion提供的动态库(作为Leap Motion SDk的一部分提供)连接到这个服务。web应用可以连接到有服务托管的WebSocket服务器上面。WebSocket提供以JSON格式信息的跟踪数据–每一帧数据每一条信息。JavaScript库，LeapJS，提供了包含这个数据的API。想要更多信息的话，可以阅读System Architecture。 Set Up the Files这个教程也使用命令行编译器和连接器(如有必要)，为了让我们更加庄主与代码而不是环境。对于如何在主流IDE上使用Leap Motion SDK创建工程，可以先看看这篇文章Setting up a Project。 如果你还没有准备好，那么可以从Developer site下载解压最新版本的Leap Motion SDk，然后安装最新的Leap Motion服务。 打开一个终端或者控制台窗口，导航到SDk ‘Sample’文件夹下。 ‘Sample.java’包含了这篇教程的最终代码，但是出于能够更加深入理解本篇教程的目的下，你可以重命名已经存在的这个Sample文件，然后在这个文件夹下创建一个新的、空白的’Sample.java’文件。保留已经存在的Sample文件，以供参考。 在你的’Sample.java’文件中，添加导入Leap Motion库的代码： 1234import com.leapmotion.leap.*; 添加主题代码，定义一个java命令行程序： 1234567891011121314class Sample { public static void main(String[] args) { // Keep this process running until Enter is pressed System.out.println(&quot;Press Enter to quit...&quot;); try { System.in.read(); } catch (IOException e) { e.printStackTrace(); } }} 这个代码简单的打印了一条信息，然后等键盘输入任意键后退出。 Get Connected下一步是在程序中添加一个控制器对象Controller–这个对象将会帮助我们连接到Leap Motion 服务/守护线程。 123456789101112131415class Sample { public static void main(String[] args) { Controller controller = new Controller(); // Keep this process running until Enter is pressed System.out.println(&quot;Press Enter to quit...&quot;); try { System.in.read(); } catch (IOException e) { e.printStackTrace(); } }} 当你创建一个Controller对象的时候，他会自动的链接到Leap Motion设备，一旦连接建立，你可以通过使用Controlller.frame()方法得到所要的跟踪数据。 这个连接的过程是异步的，所以你不能在一行创建’Controller’，然后期待能偶在下一行语句得到数据。你必须等到连接完成之后才行。但是这需要多久呢？ To Listen or not to Listen?你可以在Controlller对象上添加监听器对象Listener，这回提供一个基于事件的响应机制以响应’Controlller’的状态变化。这是本篇教程使用的方法–但是他也不总是最好的办法。 监听器的问题：Listener对象使用了独立的线程来调用你实现的每一个事件的代码。所以，使用监听器机制可以展示出贯穿你的代码中的复杂性。你需要确保的是，在你的监听器子类中实现的代码能够以一种线程安全的方式访问到你的程序。比如，你可能无法访问到跟GUI控制器有关的变量，除了主线程以外。此外，还可能有与线程的创建和清理相关的额外开销。 **Avoiding Listeners:**你可以禁止使用监听器对象通过简单地轮询Controller对象的帧(或其他的状况)，如果对于你的程序是必要的话。很多程序都已经有了一个事件循环，或者动画循环来驱动用户的输入和动画。如果这样的话，你可以在每一轮的循环中获得数据，这将尽可能的加快你使用数据的速度。 API中监听器类定义了当Controller事件触发时会被调用的函数的签名。你可以通过创建’listener’的子类，和实现你感兴趣的事件的回调函数的方式，创建一个监听器。 那么，继续我们的教程，添加’SampleListener’类到你的程序之中。为了简单，我们添加’SampleListener’类到’Sample’类一样的文件下面吧。 123456789101112class SampleListener extends Listener { public void onConnect(Controller controller) { System.out.println(&quot;Connected&quot;); } public void onFrame(Controller controller) { System.out.println(&quot;Frame available&quot;); }} 如果你已经看过了官方给的示例代码，你可能已经注意到了，回调函数的多次出现。你可能也想着吧他们都添加到自己的文件里面，如果你希望的话，但是为了保持代码简单，我们希望只专注于0nConnect()和onFrame()方法。 现在使用你刚写的类创建一个’SampleListener’对象。然后把它添加到你的控制器里。 1234567891011121314151617181920212223class Sample { public static void main(String[] args) { // Create a sample listener and controller SampleListener listener = new SampleListener(); Controller controller = new Controller(); // Have the sample listener receive events from the controller controller.addListener(listener); // Keep this process running until Enter is pressed System.out.println(&quot;Press Enter to quit...&quot;); try { System.in.read(); } catch (IOException e) { e.printStackTrace(); } // Remove the sample listener when done controller.removeListener(listener); }} 现在，你恶意运行测试一下你的’Sample’程序了。可以跳到后面查看Running the Sample的内容。 如果代码什么的搜没有错误的话(还有就是你的Leap Motion硬件设备已经连接到计算机)，那么你会看到这样的字符串”Connect”打印在终端窗口上，紧接着的是一系列以很快的速度输出的”Frame available”。如果报错而且你搞不懂为什么的话，你可以在我们的开发者论坛上向我们寻求帮助。 无论你什么时候开发出错，都可以试着打开可视化诊断工具。这个程序将展示一个Leap Motion跟踪数据的可视化观察器。你可以比较你在程序中看到的和你在可视化观察器中看到的(这两者都是用的相同的API)，来查找问题。 On Connect当你的控制器对象成功连接到Leap Motion服务/守护线程之后，而且你的Leap Motion硬件已经插入计算机，控制器对象将会改变它的isConnect()方法的属性为’true’，然后调用你的Listener.onConnect的回调。 控制器连接之后，你可以使用Controller.enableGesture()和Controller.setPolicy()方法设置控制器的参数。比如：你可以通过以下’onConnect()’方法来设置滑动手势的使能化： 123456public void onConnect(Controller controller) { System.out.println(&quot;Connected&quot;); controller.enableGesture(Gesture.Type.TYPE_SWIPE);} On Frame在Leap Motion系统中，所有跟踪数据送达都是通过Frame对象来实现的。你可以从你的控制器(当他连接之后)通过调用Controller.frame()方法来获得’Frame’对象。当一个新的frame数据有效时，你的Listener子类的onFrame()回调方法将会被调用。当你不在使用监听器时，你可以比较id()的值和你处理的上一帧，判断是否是一个新的frame(帧)。注意，通过设置frame()函数的’history’参数，你可以获得更早之前的帧(里面至少有60以上的帧的数据被保存着)。所以，如有必要的话，你可以使轮询速率变得比Leap Motion数据帧的速率还慢，可以处理每一帧的数据。 为了获得数据帧frame，要添加frame()方法到你的onframe()回调函数里面： 12345public void onFrame(Controller controller) { Frame frame = controller.frame();} 然后，打印出Frame对象的一些属性： 123456789101112public void onFrame(Controller controller) { Frame frame = controller.frame(); System.out.println(&quot;Frame id: &quot; + frame.id() + &quot;, timestamp: &quot; + frame.timestamp() + &quot;, hands: &quot; + frame.hands().count() + &quot;, fingers: &quot; + frame.fingers().count() + &quot;, tools: &quot; + frame.tools().count() + &quot;, gestures &quot; + frame.gestures().count());} 那么，再次运行你的Sample，把一只或者两支手掌放在Leap Motion设备上面，你会在控制台窗口看到每一帧的基本属性。 本次教程在这就结束了，但是你可以看看官方提供的Sample文件中的其他代码。比如说，在一个Frame里面如何获得手掌Hand，手指Finger，手臂Arm，骨头Bone 还有手势Gesture对象。 Running the Sample运行一个示例应用： 编译示例应用： 在Windows系统下，确保’Sample.java’和’LeapJava.jar’在当前文件夹下面，然后输入以下命令行在命令行提示符后面，并运行： 1javac -classpath LeapJava.jar Sample.java 在Mac系统上，确保’Sample.java’和’LeapJava.jar’在当前文件夹下面，然后在终端里面运行以下命令行： 123javac -classpath ./LeapJava.jar Sample.java 运行示例应用： 在Windows系统下，确保’Sample.class’,’LeapJava.jar’,’LeapJava.dll’,和’Leap.dll’在同一个文件夹下。如果你是用的是32-bit版本的JVM，需要使用SDk下的lib\\x86文件夹下的.dll文件。如果你是用的是64-bit版本的JVM，需要使用SDk下的lib\\x64文件夹下的.dll文件.在命令行提示符后输入并运行以下命令行： 1java -classpath &quot;LeapJava.jar;.&quot; Sample 在Mac系统下，确保’Sample.class’,’LeapJava.jar’,’LeapJava.dll’,和’Leap.dll’在同一个文件夹下。在终端中运行命令行： 123java -classpath &quot;./LeapJava.jar:.&quot; Sample 当应用程序初始化并连接之后到Leap之后，你会看到”Connect”信息被打印在标准输出中。你还会看到frame的信息，在每一次’onframe’事件被调用后。","link":"/2022/07/24/2016-01-18-Introduction-to-Leap-Motion/"},{"title":"Activity on Android","text":"前言Activity是Android组件中最基本也是最为常见用的四大组件（Activity，Service服务,Content Provider内容提供者，BroadcastReceiver广播接收器）之一。Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。在一个Android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 目录 Activity的状态 Activity的生命周期 Activity栈 Activity的加载模式以及区别 Activity 之间通信 Activity 的 Intent Filter 一、Activity的状态在 Android 中，Activity 拥有四种基本状态： 活动态Active/Runing：当一个Activity在Activity栈顶，它处于可视的、有焦点、可接受用户输入的激活状态。Android试图尽最大可能保持它活动状态，杀死其它Activity来确保当前活动Activity有足够的资源可使用。当另外一个Activity被激活，这个将会被暂停。 暂停态Paused：当 Activity 被另一个透明或者 Dialog 样式的 Activity 覆盖时的状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。当被暂停，一个Activity仍会被当成活动状态，只不过是不可以接受用户输入。在极特殊的情况下，Android将会杀死一个暂停的Activity来为活动的Activity提供充足的资源。当一个Activity变为完全隐藏，它将会变成停止。 停止态Stoped：当 Activity 被另外一个 Activity 覆盖、失去焦点并不可见时处于 Stoped状态。当一个Activity不是可视的，它“停止”了。这个Activity将仍然在内存中保存它所有的状态和会员信息。尽管如此，当其它地方需要内存时，它将是最有可能被释放资源的。当一个Activity停止后，一个很重要的步骤是要保存数据和当前UI状态。一旦一个Activity退出或关闭了，它将变为待用状态。 待用态Killed：在一个Activity被杀死后和被装在前，它是待用状态的。待用Acitivity被移除Activity栈，并且需要在显示和可用之前重新启动它。 当一个 Activity 实例被创建、销毁或者启动另外一个 Activity时，它在这四种状态之间进行转换，这种转换的发生依赖于用户程序的动作。下图说明了Activity在不同状态间转换的时机和条件： 如上所示，Android 程序员可以决定一个 Activity 的“生”，但不能决定它的“死”，也就时说程序员可以启动一个 Activity，但是却不能手动的“结束”一个 Activity。当你调用 Activity.finish()方法时，结果和用户按下 BACK 键一样：告诉 Activity Manager 该 Activity 实例完成了相应的工作，可以被“回收”。随后 Activity Manager 激活处于栈第二层的 Activity 并重新入栈，同时原 Activity 被压入到栈的第二层，从 Active 状态转到 Paused 状态。例如：从 Activity1 中启动了 Activity2，则当前处于栈顶端的是 Activity2，第二层是 Activity1，当我们调用 Activity2.finish()方法时，Activity Manager 重新激活 Activity1 并入栈，Activity2 从 Active 状态转换 Stoped 状态，Activity1. onActivityResult(int requestCode, int resultCode, Intent data)方法被执行，Activity2 返回的数据通过 data参数返回给 Activity1。 二、 Activity的生命周期Activty的生命周期的也就是它所在进程的生命周期。 一个Activity的启动顺序：onCreate()——&gt;onStart()——&gt;onResume() 当另一个Activity启动时:第一个Activity onPause()——&gt;第二个Activity onCreate()——&gt;onStart()——&gt; onResume() ——&gt;第一个Activity onStop() 当返回到第一个Activity时：第二个Activity onPause() ——&gt; 第一个Activity onRestart()——&gt;onStart()——&gt;onResume() ——&gt;第二个Activity onStop()——&gt;onDestroy() 一个Activity的销毁顺序:（情况一）onPause()——&gt;（情况二）onPause()——&gt;onStop()——&gt;（情况三）onPause()——&gt;onStop()——&gt;onDestroy() 每一个活动（ Activity ）都处于某一个状态，对于开发者来说，是无法控制其应用程序处于某一个状态的，这些均由系统来完成。但是当一个活动的状态发生改变的时候，开发者可以通过调用 onXX()的方法获取到相关的通知信息。 在实现 Activity 类的时候，通过覆盖（ override ）这些方法即可在你需要处理的时候来调用。 1、onCreate ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。 onCreate 方法有一个参数，该参数可以为空( null )，也可以是之前调用 onSaveInstanceState()方法保存到存储设备中的数据。 2、onStart ：该方法在 onCreate() 方法之后被调用，或者在 Activity 从 Stop 状态转换为 Active 状态时被调用。该方法的触发表示所属活动将被展现给用户。 3、onResume ：当一个活动和用户发生交互的时候，触发该方法。在 Activity 从 Pause 状态转换到 Active 状态时被调用。 4、onPause ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。 5、onStop：当一个活动不再需要展示给用户的时候，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发 onStop 方法。 所以保存状态信息是应该在onPause时做，而不是onStop时做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。 6、onRestart ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。 7、onDestroy ：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，系统会直接结束这个活动而不会触发该方法。 8、onSaveInstanceState ：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。 通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，已经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。 三、Activity栈Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示： 每个Activity的状态是由它在Activity栈（是一个后进先出LIFO，包含所有正在运行Activity的队列）中的位置决定的。 一个应用程序的优先级是受最高优先级的Activity影响的。当决定某个应用程序是否要终结去释放资源，Android内存管理使用栈来决定基于Activity的应用程序的优先级。 四、Activity的加载模式以及区别在Android的多Activity开发中，Activity之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个Activity实例，而不是生成大量的重复的Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个Activity实例。 在Android里，有4种Activity的启动模式，分别为： 1、标准模式standard：一调用startActivity()方法就会产生一个新的实例。 2、singleTop:如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。 3、singleTask: 会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。 4、singleInstance: 这个跟singleTask基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。 这些启动模式可以在功能清单文件AndroidManifest.xml中的launchMode属性进行设置。 相关的代码中也有一些标志可以使用,比如我们想只启用一个实例,则可以使用 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 标志，这个标志表示：如果这个activity已经启动了，就不产生新的activity，而只是把这个activity实例加到栈顶来就可以了。 123Intent intent =new Intent(ReorderFour.this,ReorderTwo.class); intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);startActivity(intent); 四种加载模式的区别: 1、所属task的区别 一般情况下，standard和singleTop的Activity的目标task，和收到的Intent的发送者在同一个task内，就相当于谁调用它，它就跟谁在同一个Task中。 除非Intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。singleTask和singleInstance总是把要启动的Activity作为一个task的根元素，他们不会被启动到一个其他task里。 2、是否允许多个实例 standard和singleTop可以被实例化多次，并且是可以存在于不同的task中。这种实例化时一个task可以包括一个activity的多个实例。 singleTask和singleInstance则限制只生成一个实例，并且是task的根元素。 singleTop 要求在创建intent的时候，如果栈顶已经有要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。 3、是否允许其它Activity存在于本task内 singleInstance独占一个task，其它Activity不能存在那个task里。 如果它启动了一个新的Activity，不管新的Activity的launch mode如何，新的Activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。 而另外三种模式，则可以和其它activity共存。 4、是否每次都生成新实例 standard对于每一个启动Intent都会生成一个activity的新实例。 singleTop的Activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 比如：现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是standard的，则生成D的一个新实例，栈变为A－B－C－D－D。如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D。 如果这时候给B发Intent的话，不管B的launchmode是standard还是 singleTop，都会生成B的新实例，栈状态变为A-B-C-D-B。 singleInstance是其所在栈的唯一Activity，它会每次都被重用。 singleTask如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。当已经存在的Activity实例处理新的intent时候，会调用onNewIntent()方法，如果收到intent生成一个Activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个Activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。 五、Activity 之间通信在 Android 中，不同的Activity实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。 1、使用 Intent 通信 Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。 在通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。 如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去： 1234567Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity 那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息： 1234Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容bundle.getString(&quot;string_key&quot;); 上面我们通过 bundle对象来传递信息，bundle维护了个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法： 1234Intent intent =new Intent(EX06.this,OtherActivity.class); intent.putExtra(&quot;boolean_key&quot;, true); intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;); startActivity(intent); 123Intent intent=getIntent(); intent.getBooleanExtra(&quot;boolean_key&quot;,false); intent.getStringExtra(&quot;string_key&quot;); 2、使用 SharedPreferences SharedPreferences 使用 xml 格式为 Android 应用提供一种永久的数据存贮方式。对于一个 Android 应用，它存贮在文件系统的 /data/ data/your_app_package_name/shared_prefs/目录下，可以被处在同一个应用中的所有 Activity 访问。Android 提供了相关的 API 来处理这些数据而不需要程序员直接操作这些文件或者考虑数据同步问题。 1234567891011// 写入 SharedPreferences SharedPreferences preferences = getSharedPreferences(&quot;name&quot;, MODE_PRIVATE); Editor editor = preferences.edit(); editor.putBoolean(&quot;boolean_key&quot;, true); editor.putString(&quot;string_key&quot;, &quot;string_value&quot;); editor.commit(); // 读取 SharedPreferences SharedPreferences preferences = getSharedPreferences(&quot;name&quot;, MODE_PRIVATE); preferences.getBoolean(&quot;boolean_key&quot;, false); preferences.getString(&quot;string_key&quot;, &quot;default_value&quot;); 3、其它方式 Android 提供了包括 SharedPreferences 在内的很多种数据存贮方式，比如 SQLite，文件等，程序员可以通过这些 API 实现 Activity 之间的数据交换。如果必要，我们还可以使用 IPC 方式。 六、Activity 的 Intent FilterIntent Filter 描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。在 Android 的 AndroidManifest.xml 配置文件中可以通过 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。 当程序员使用 startActivity(intent) 来启动另外一个 Activity 时，如果直接指定 intent 对象的 Component 属性，那么 Activity Manager 将试图启动其 Component 属性指定的 Activity。否则 Android 将通过 Intent 的其它属性从安装在系统中的所有 Activity 中查找与之最匹配的一个启动，如果没有找到合适的 Activity，应用程序会得到一个系统抛出的异常。Activity中Intent Filter 的匹配过程如下： 1、Action 匹配Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 Intent Filter 可以包含多个 Action。在 AndroidManifest.xml 的 Activity 定义时可以在其 节点指定一个 Action 列表用于标示 Activity 所能接受的“动作”，例如： 12345 &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;action android:name=&quot;com.cyw.myaction&quot; /&gt; …… &lt;/intent-filter&gt; 如果我们在启动一个 Activity 时使用这样的 Intent 对象： 12Intent intent =new Intent(); intent.setAction(&quot;com.cyw.myaction&quot;); 那么所有的 Action 列表中包含了“com.cyw.myaction”的 Activity 都将会匹配成功。Android 预定义了一系列的 Action 分别表示特定的系统动作。这些 Action 通过常量的方式定义在 android.content. Intent中，以“ACTION_”开头。我们可以在 Android 提供的文档中找到它们的详细说明。 2、URI 数据匹配 一个 Intent 可以通过 URI 携带外部数据给目标组件。在 节点中，通过 节点匹配外部数据。mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。如下： 12&lt;data android:mimeType=&quot;mimeType&quot; android:scheme=&quot;scheme&quot; android:host=&quot;host&quot; android:port=&quot;port&quot; android:path=&quot;path&quot;/&gt; 如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功时 URI 数据匹配才会成功。 3、Category 类别匹配节点中可以为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。","link":"/2022/07/24/2016-04-04-Android-Activity/"},{"title":"Android热修复方案","text":"前言当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。 这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布App，不再需要用户重新下载，覆盖安装？ 虽然Android系统并没有提供这个技术，但是很幸运的告诉大家，答案是：可以，热补丁动态修复技术可以解决以上这些问题。 对于热修复方案，当前市场有四种解决方案，分别是 Xposed、AndFix、ClassLoader、Proxy/Delegate。前两个是阿里开源的框架，第三个是QQ空间团队想出的对策。在我看来，前两个方案的思路是极其相似的，都是想要通过指针替换掉出Bug的方法、类，不同的是Xposed将需要替换的方法连接到hookedMethodCallback，以他来实现替换后方法的调配，而AndFix就比较简洁粗暴了，直接就是获取需要替换的方法指针，将指针指向修改之后的新的java代码；相比之下，ClassLoader方案便较为巧妙的多了，他巧妙利用了BaseDexClassLoader的机制，类似于dex分包技术。Proxy/Delegate的方案则是使用ProxyApplication动态加载主程序dex。 目录 Xposed AndFix ClassLoader 基于Proxy/Delegate 四种方案的比较 基于以上四种方案的开源框架以及比较 一、Xposed大体上的原理是： 1、首先，我们来理解一个概念——Zygote进程。 在Android系统中，每一个应用程序都是由Zygote进程进行孵化出来的。Zygote进程是由init进程创建而成。Zygote在启动时候，创建了一个Davlik虚拟机实例，每当Zygote进程创建孵化出一个应用程序进程时，都会将这个Daclik虚拟机实例进行拷贝一份，拷贝到新创建的应用程序进程之中，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。 这样看来，Zygote进程就犹如一个盛产的孕妇，每生产一个孩子，也就是应用程序进程，都会给孩子先打疫苗（拷贝一份Davlik虚拟机实例到应用程序之中），让孩子们能够正常的健康成长。 Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包（Xposed的关键jar包）加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。 2、接着，我们再来看看Xposed的关键思想Hook。 Hook的中文翻译是，挂钩、钓钩，比较形象。那么它要用来钓哪一条鱼的呢？根据不同的鱼，我们以便准备不同的鱼饵。 所以，在Android系统启动时候Zygote进程加载的XposedBridge jar包，就有了用武之地。在XposedBridge之中有一个私有的方法——hookMethodNative，它将一个方法作为输入参数并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。 在hookMethodNative的实现中，会调用XposedBridge中的handleHookedMethod这个方法来传递参数。而这个方法，我们可以称之为鱼竿。它将一个方法对象，也就是我们需要替换的方法或者类，作为输入参数，当然，你可以使用java的反射几只来获取这个方法，不过，这个方法对象，这个输入参数就是我们说的“鱼饵”了，根据鱼饵，我们使用鱼竿，便可以钓起我们想要钓起的大鱼。而大鱼便是所要hook的方法对象Method的指针。得到所需要替换的Method指针之后，因为我们的目的是要替换有bug的方法。所以，我们将得到的指针链接到hookedMethodCallback上面去，并设置该Method指向替换成为的方法，以便hookedMethodCallback可以获取真正期望执行的java方法。 现在所有被hook的方法，都指向了hookedMethodCallback的c方法中，然后在此方法中实现调用替换成为的java方法。 handleHookedMethod这个方法类似于一个统一调度的Dispatch任务分派例程，其对应的底层的C++函数是xposedCallHandler。而handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数，并调用他们的before, after函数。 那么，hook的具体过程是： 1、首先通过DexClassloader（这个会在ClassLoader部分具体说明）来加载所要hook的方法，分析类后，进c++层，拿到要hook的Method类，然后在handleHookedMethod中，通过dvmslotTomethod方法获取所要替换的Method*指针。 1Method* method = dvmSlotToMethod(declaredClass, slot); declaredClass就是所hook方法所在的类，对应的object。slot是Method类中，描述此java对象在vm中的索引；那么通过这个方法，我们就获取了c层的Method指针 2、将该方法标记为一个native方法 1SET_METHOD_FLAG(method, ACC_NATIVE); 3、重定向该方法到hookedMethodCallback，这样当被hook的java方法执行时，就会调到c层的hookedMethodCallback方法。通过meth-&gt;nativeFunc重定向MethodCallBridge到hookedMethodCallback这个方法上，控制这个c++指针是无视java的private的。 1method-&gt;nativeFunc = &amp;hookedMethodCallback; 另外，在method结构体中有 1method-&gt;insns = (const u2*) hookInfo; 用insns指向替换成为的方法，以便hookedMethodCallback可以获取真正期望执行的java方法。现在所有被hook的方法，都指向了hookedMethodCallbackc方法中，然后在此方法中实现调用替换成为的java方法。 3、优点 1）无需重启就可以达到修复bug的目的 2）多个模块可同时进行安装 3）无需修改任何的APK 4、缺点 1）需要Android 的root权限 2）Dexposed不支持Art模式（5.0+），且写补丁有点困难，需要反射写混淆后的代码，粒度太细，要替换的方法多的话，工作量会比较大。 二、AndFix1、AndFix的原理就是方法的替换，把有bug的方法替换成补丁文件中的方法。 注：在Native层使用指针替换的方式替换bug方法，以达到修复bug的目的。 使用AndFix修复热修复的整体流程： AndFix，我觉得是阿里开源的自动化程度比较高的热修复框架了。因为你发现，框架、工具已经可以做到帮你查找修改前修改后类的不同，并能够将之打包成为对应的补丁。开发人员所要负责的不过是对于Bug的修改而已。 修复补丁的具体过程是： 1）我们及时修复好bug之后，我们可以apkpatch工具将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件。若果这个时候，我们把后缀改成zip再解压开，里面有一个dex文件。反编译之后查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。 2）客户端得到补丁文件后就会根据annotation来寻找需要替换的方法。从AndFixManager.fix方法开始，客户端找到对应的需要替换的方法，然后在fix方法的具体实现中调用fixClass方法进行方法替换过程。 3）由JNI层完成方法的替换。fixClass方法遍历补丁class里的方法，在jni层对所需要替换的方法进行一一替换。关键代码如下： 123456789101112131415161718192021private void replaceMethod(ClassLoader classLoader, String clz, String meth, Method method) { try { String key = clz + &quot;@&quot; + classLoader.toString(); Class&lt;?&gt; clazz = mFixedClass.get(key); if (clazz == null) {// class not load // 要被替换的class Class&lt;?&gt; clzz = classLoader.loadClass(clz); // 这里也很黑科技，通过C层，改写accessFlags，把需要替换的类的所有方法（Field）改成了public，具体可以看Method结构体 clazz = AndFix.initTargetClass(clzz); } if (clazz != null) {// initialize class OK mFixedClass.put(key, clazz); // 需要被替换的函数 Method src = clazz.getDeclaredMethod(meth, method.getParameterTypes()); // 这里是调用了jni，art和dalvik分别执行不同的替换逻辑，在cpp进行实现 AndFix.addReplaceMethod(src, method); } } catch (Exception e) { Log.e(TAG, &quot;replaceMethod&quot;, e); }} 2、优点 1）可以多次打补丁。如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。 2）安全性 readme提示开发者需要验证下载过来的apatch文件的签名是否就是在使用apkpatch工具时使用的签名，如果不验证那么任何人都可以制作自己的apatch文件来对你的APP进行修改。但是我看到AndFix已经做了验证，如果补丁文件的证书和当前apk的证书不是同一个的话，就不能加载补丁。官网还有一条，提示需要验证optimize file的指纹，应该是为了防止有人替换掉本地保存的补丁文件，所以要验证MD5码，然而SecurityChecker类里面也已经做了这个工作。。但是这个MD5码是保存在sharedpreference里面，如果手机已经root那么还是可以被访问的。 3）不需要重启APP即可应用补丁。 3、缺点 1）不支持YunOS2）无法添加新类和新的字段3）需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露4）使用加固平台可能会使热补丁功能失效5）无法添加类和字段 三、ClassLoader其实我更希望将之称之为MutilDex方案，因为他是基于谷歌的MutilDex项目思想而来，dex拆分是其核心。 1、ClassLoader的原理 首先，在说到这个方案的原理的时候，我们需要先了解一下Android的ClassLoader体系 由上图可以看出，在叶子节点上，我们能使用到的是DexClassLoader和PathClassLoader，这也是Android中加载类一般使用到的。 首先看下这两个类的区别： 对于PathClassLoader，从文档上的注释来看： Provides a simple {@link ClassLoader} implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s). Android是使用这个类作为其系统类和应用类的加载器,只能去加载已经安装到Android系统中的apk文件。 对于DexClassLoader，依然看下注释： A class loader that loads classes from {@code .jar} and {@code .apk} files containing a {@code classes.dex} entry. This can be used to execute code not installed as part of an application. 可以用来从.jar和.apk类型的文件内部加载classes、dex文件。可以用来执行非安装的程序代码。Android应用就是用它来加载; 那这两个ClassLoader有与我们的热修复有什么联系？ 好吧，我们先来看看代码吧： 123456789101112131415//BaseDexClassLoader: @Override protected Class&lt; ?&gt; findClass(String name) throws ClassNotFoundException { List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn't find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } 由上述函数可知，当我们需要加载一个class时，实际是从pathList中去需要的，查阅源码，发现pathList是DexPathList类的一个实例。好，接着去分析DexPathList类中的findClass函数。 123456789101112131415 public Class findClass(String name, List&lt;Throwable&gt; suppressed) { for (Element element : dexElements) { DexFile dex = element.dexFile; if (dex != null) { Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) { return clazz; } } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } 那么我们开始有点头绪了。我们在使用类的时候，会让PathClassLoader或者DexClassLoader对该类进行类加载。而加载的过程就是，遍历一个装在dex文件（每个dex文件实际上是一个DexFile对象）的数组（Element数组，Element是一个内部类），然后依次去加载所需要的class文件，直到找到为止。 BaseDexClassLoader中有个pathList对象，pathList中包含一个DexFile的集合dexElements，而对于类加载，就是遍历这个集合，通过DexFile去寻找。一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。 而这里面就正好让我们有机可乘。对，也就是理论上，如果在不同的dex中有相同的类存在，那么会优先选择排在前面的dex文件的类，如下图： 在此基础上，我们觉得可以用来作为热补丁的方案。把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex插入到Elements的最前面，这样，在类加载的过程中便会优先加载补丁包中dex的类，如下图： 嗯，原理大致就是这样。 但是，在实现过程中，我们还会遇到一个CLASS_ISPREVERIFIED问题。 什么是CLASS_ISPREVERIFIED问题？ 首先我们来看看一下代码： 这段代码是dex转化成odex(dexopt)的代码中的一段，我们知道当一个apk在安装的时候，apk中的classes.dex会被虚拟机(dexopt)优化成odex文件，然后才会拿去执行。 虚拟机在启动的时候，会有许多的启动参数，其中一项就是verify选项，当verify选项被打开的时候，上面doVerify变量为true，那么就会执行dvmVerifyClass进行类的校验，如果dvmVerifyClass校验类成功，那么这个类会被打上CLASS_ISPREVERIFIED的标志。这样看来，打上CLASS_ISPREVERIFIED其实是Android的一种性能优化方式。 那么具体的校验过程是什么样子的呢？此代码在DexVerify.cpp中，如下： 概括一下就是如果以上方法中直接引用到的类（第一层级关系，不会进行递归搜索）和clazz都在同一个dex中的话，那么这个类就会被打上CLASS_ISPREVERIFIED。 而被打上CLASS_ISPREVERIFIED之后，在ClassLoader加载与需要修改类相关的相关类时候，却发现他们两个却不是来自于同一个dex的，这个时候就会抛出异常了。 所以我们接下要做的就是阻止相关类被打上CLASS_ISPREVERIFIED标记。 一般采用的方案是往所有类的构造函数里面插入了一段代码，代码如下： 123if (ClassVerifier.PREVENT_VERIFY) { System.out.println(AntilazyLoad.class);//需要修改的类} 这样，需要与修改的类以及其相关类，在进行校验的时候，因为修改后的类所在的dex与原来的dex不同，也就是与相关类的dex不同，这样，他们就不会被打上CLASS_ISPREVERIFIED了。 为了实现以上操作，QQ空间采用了javassist动态代码注入。用javassist将这个类在编译打包的过程中插入到目标类中。 大致的流程是：在dx工具执行之前，将LoadBugClass.class文件呢，进行修改，再其构造中添加System.out.println(dodola.hackdex.AntilazyLoad.class)，然后继续打包的流程。注意：AntilazyLoad.class这个类是独立在hack.dex中。 总结下，其实我们需要做的就是两件事： 1、动态改变BaseDexClassLoader对象间接引用的dexElements； 2、在app打包的时候，阻止相关类去打上CLASS_ISPREVERIFIED标志。所有与该类相关的类都需要进行动态注入，可进行修改，也是需要进行fix的对象。 四、基于Proxy/Delegate当项目有加壳子,插件化或热修复等需求的时候,可以使用Proxy/Delegate Application框架的方式。 在正常的模式中,一个程序一般只有一个Application入口,而Proxy/Delegate模式中需要有两个Application,原程序的Application改为Delegate Application,再新加一个Proxy Application,由Proxy Application 提供一系列的个性化定制,再将所有的context和context相关的引用全部转化为Delegate Application的实例,让外界包括Delegate Application自身都以为该App的Application入口就是Delegate Application. 采用的是Proxy/Delegate Application框架。 主要实现的流程: 1、替换主程序dex文件为代理启动程序的dex文件 2、代理启动程序启动后,动态加载主程序dex 3、ProxyApplication替换消除本身Context引用为MyApplication 4、启动主程序的Application. 经过上述的步骤处理,由于程序启动dex只是一个代理,而主程序的dex是动态加载的,所以就可以达到不升级主程序不更改版本号只升级dex文件来修复线上紧急bug的目的. 五、四种方案的比较 Xposed方法生成补丁难度较大，需要反射写混淆后的代码，粒度太细，如果替换方法很多的话，工作量巨大。 AndFix支持2.3 - 6.0系统，但JNI不像JAVA那样标准，所以偶尔会有未知的机型异常。从实现来说，类似Xposed，通过JNI来替代方法，更加简洁的完成补丁修复，应用PATCH不需要重启。但由于实现上直接跳过了类初始化，设置为初始化完毕，所以静态函数、静态成员、构造函数都会出现问题，复杂的类Class.forName很可能直接崩溃。 ClassLoader方案支持2.3 - 6.0系统，对启动速度会有略微影响，而且只能下次启动生效。 Proxy/Delegate方案，对于dex的要求比较高，如果DEx文件较为庞大，启动速度会变慢。 相比而言，ClassLoader方案较为可靠，但是如果Dex文件较为庞大，启动速度会变慢；而AndFix则适用于应用不重启即可修复，且方法够简单；Xposed方案较为复杂，暂不考虑。 六、基于以上四种方案的开源框架以及比较1、Dexpost： 1）原理：在底层虚拟机运行时hoop方法； 2）缺点：适配方面存在一些问题，目前不支持android6.0，5,1；art运行时； 3）优点：无需重启就可以达到修复bug的目的； 2、AndFix： 1）原理：在Native层使用指针替换的方法替换bug方法，达到修复bug的目的； 2）缺点： 底层替换，稳定性方面可能需要实际检测； 不支持YunOS； 无法添加新类和新的字段； 需要使用加固前的apk制作补丁，但是补丁文件很容易被反编译，也就是修改过的类源码容易泄露； 使用加固平台可能会使热补丁功能失效； 无法添加类和字段； 3）优点：无需中期就可以达到修复bug的目的； 3、HotFix： 1）原理：通过替换类加载器中bugclass，达到修复bug的目的； 2）缺点：需要重新启动才可以修复bug； 3）优点：java运行层修复，稳定性较好； 4、Nuwa： 1）原理：通过替换类加载器中bugclass，达到修复bug的目的； 2）缺点：需要重新启动才可以修复bug； 3）优点：java运行层修复，稳定性较好；自动化热修复 5、DroidFix： 1）原理：通过替换类加载器中bugclass，达到修复bug的目的； 2）缺点：需要重新启动才可以修复bug； 3）优点：java运行层修复，稳定性较好； 6、dynamic-load-apk 1）缺点：不支持Service和BroadcastReceiver；迁移成本高，需要修改插件，插件app需要继承自proxyActivity 2）优点: 插件无需安装host即可吊起；支持R访问插件资源；插件支持Activity和FragmentActivity；基本无反射调用；插件安装后任可独立运行 7、Droid Plugin 1）缺点：无法使用自定义资源的通知；法注册一些特殊Intent Filter的组件（四大组件）；对Native支持不好 2）优点：插件无需任何修改，可独立安装运行，也可以做插件运行；四大组件无需在Host程序注册；超强隔离性，不同插件运行在不同的进程中；资源完全隔离；实现进程管理，插件的空进程会被及时回收，占用内存低；插件的静态广播会被当作动态处理，如果插件没有运行，静态广播永远不会触发；API侵入性低 8、DynamicAPK 1）优点：迁移成本低（无需做任何activity/fragment/resource的proxy实现）不使用代理来管理插件的activity/fragment的生命周期。修改后aapt会处理插件种的资源，R.java中的资源引用和普通Android工程没有区别，开发者可以保持原有的开发规范； 更加有利于并发开发； 提升编译速度； 提升启动速度。 2）缺点： dex解压、dexopt、加载耗时较长，使用按需加载启动时间过长","link":"/2022/07/24/2016-04-09-Android-HotFix/"},{"title":"Java 关键字总结","text":"前言| 访问控制 | private | protected | public || 类，方法和变量修饰符 | abstract | class | extends | final | implements | interface | native || | new | static | strictfp | synchronized | transient | volatile || 程序控制 | break | continue | return | do | while | if | else || | for | instanceof | switch | case | default || 错误处理 | try | catch | throw | throws | finally || 包相关 | import | package || 基本类型 | boolean | byte | char | double | float | int | long || | short | null | true | false || 变量引用 | super | this | void || 保留字 | goto | const | 详细解释1、访问控制 private 私有的 private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 protected 受保护的 protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。 public 公共的 public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 可能只会在其他任何类或包中引用 public 类、方法或字段。 那么我们总结一下，Java之中的权限访问修饰符（其实还有一种权限访问情况，就是默认情况，暂且称作default吧）： | 访问权限 | 当前类 | 包 | 子类 | 其他包 || public | ∨ | ∨ | ∨ | ∨ || protect | ∨ | ∨ | ∨ | × || default | ∨ | ∨ | × | × || private | ∨ | × | × | × | 2、类、方法和变量修饰符 abstract 声明抽象 abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。 class类 class 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。要使用类，通常使用 new 操作符将类的对象实例化，然后调用类的方法来访问类的功能。 extends 继承、扩展 extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。子类继承父类的所有 public 和 protected 变量和方法（但是不包括构造函数）。 子类可以重写父类的任何非 final 方法。一个类只能扩展一个其他类。 extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。 final 最终、不可改变 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。final方法在编译阶段绑定，称为静态绑定(static binding)。下面就从这四个方面来了解一下final关键字的基本用法。 1、修饰类 当用final修饰一个类时，表明这个类不能被继承，不能有子类。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 2、修饰方法 下面这段话摘自《Java编程思想》： 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。 还有就是，类的private方法会隐式地被指定为final方法。 3、修饰变量 修饰变量是final用得最多的地方。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。 4、final参数 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值或者引用指向。道理同final变量。 概括起来就是： 在A类是声明为final类型的方法，那么不能在子类里被覆盖； 如果A类被声明为final类型的类，那么B类不能继承A类； 如果成员变量声明为final类型，那么成员变量不能被修改； 注意： 1、一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。两者是相互矛盾的。 2、当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。 3、final变量和普通变量的区别。当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会进行优化，会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。而普通变量在编译时，确定不了自身的值，需要在运行时才能知道。 4、局部内部类和匿名内部类只能访问局部final变量。因为这里的局部变量，需要在编译阶段便需要确定下来的。也就是说，如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。 implements实现 implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中所声明的所有方法的实现。一个类可以实现多个接口。 interface 接口 interface 关键字用来声明新的 Java 接口，接口是方法的集合。 接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。 实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。 native 本地 native 关键字可以应用于方法，以指示该方法是用Java以外的语言实现的，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。。 Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤： １、在Java中声明native()方法，然后编译； ２、用javah产生一个.h文件； ３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； ４、将第三步的.cpp文件编译成动态链接库文件； ５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 JAVA本地方法适用的情况 1、为了使用底层的主机平台的某个特性，而这个特性不能通过JAVA API访问 2、为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用JAVA编写的 3、为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。 new 新,创建 new 关键字用于创建类的新实例。 new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。参数集合必须与类的构造方法的签名匹配。 = 赋值号左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。 static 静态 static可以用于修饰属性，可以修饰代码块，也可以用于修饰方法，还可以用于修饰类。 1、static修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态的成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也会随之发生变化。如果一个成员变量是static的，那么我们可以通过‘类名.成员变量名’的方式来使用它。 2、static修饰方法：static修饰的方法叫做静态方法。对于静态方法来说，可以使用‘类名.方法名’的方式来访问。静态方法只能继承，不能重写（Override），因为重写是用于表现多态的，重写只能适用于实例方法，而静态方法是可以不生成实例直接用类名来调用，这就会与重写的定义所冲突，与多态所冲突，所以静态方法不能重写，只能是隐藏。 static方法与非static方法：不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态的成员变量。可以在非静态方法中访问静态的成员变量：因为静态方法可以直接用类名来调用，而非静态成员变量是在创建对象实例时才为变量分配内存和初始化变量值。 不能在静态方法中使用this关键字：因为静态方法可以直接用类名来调用，而this实际上是创建实例时，实例对应的一个应用，所以不能在静态方法上使用this。 3、static修饰代码块：静态代码块。静态代码块的作用也是完成一些初始化工作。首先执行静态代码块，然后执行构造方法。静态代码块在类被加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到Java虚拟机上（JVM），然后由JVM加载这个类来生成对象。 类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所以静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以new一次就会调用构造方法一次。如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类的静态代码块，一直执行到最底层类的静态代码块，然后再去执行最顶层类的构造方法，一直执行到最底层类的构造方法。注意：静态代码块只会执行一次。 4、static修饰类：这个有点特殊，首先，static是可以用来修饰类的，但是static是不允许用来修饰普通类，只能用来修饰内部类，被static所修饰的内部类可以用new关键字来直接创建一个实例，不需要先创建外部类实例。static内部类可以被其他类实例化和引用（即使它是顶级类）。 其实理解起来也简单。因为static主要是修饰类里面的成员，包括内部类、属性、方法这些。修饰这些变量的目的也很单纯，那就是暗示这个成员在该类之中是唯一的一份拷贝，即便是不断的实例化该类，所有的这个类的对象都会共享这些static成员。这样就好办了。因为是共享的、唯一的，所以，也就不需要在实例化这个类以后再通过这个类来调用这个成员了，显然有点麻烦，所以就简单一点，直接通过类名直接调用static成员，更加直接。然而这样设置之后，就出现了一个限制，就是，static方法之中不能访问非static属性，因为这个时候非static属性可能还没有给他分配内存，该类还没有实例化。 所以，通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。 strictfp 严格,精准 strictfp的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。而一旦使用了strictfp来声明一个类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果想让浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。 可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。 synchronized线程、同步 synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 一般的用法有： 1、synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁， 每个synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。 在Java中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized块。 2、synchronized块。 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 这里的关键之处在于，这个object的对象锁只有一把，一把锁对应一个线程。 transient 短暂 transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 volatile 易失 volatile 关键字用于表示可以被多个线程异步修改的成员变量。 注意：volatile 关键字在许多 Java 虚拟机中都没有实现。 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 Volatile修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 Java语言规范中指出： 为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。 这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。 而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝,而应直接与共享成员变量交互。 使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。 由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。 Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。 3、程序控制语句 break 跳出，中断 break 关键字用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 break 总是退出最深层的 while、for、do 或 switch 语句。 continue 继续 continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。 return 返回 return 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。如果方法具有非 void 的返回类型，return 语句必须具有相同或兼容类型的参数。返回值两侧的括号是可选的。 do 运行 do 关键字用于指定一个在每次迭代结束时检查其条件的循环。 do 循环体至少执行一次。条件表达式后面必须有分号。 while 循环 while 关键字用于指定一个只要条件为真就会重复的循环。 if 如果 if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。 if 语句可以有可选的 else 子句，该子句包含条件为 false 时将执行的代码。 包含 boolean 操作数的表达式只能包含 boolean 操作数。 else 否则 else 关键字总是在 if-else 语句中与 if 关键字结合使用。else 子句是可选的，如果 if 条件为 false，则执行该子句。 for 循环 for 关键字用于指定一个在每次迭代结束前检查其条件的循环。 for 语句的形式为 for(initialize; condition; increment) 控件流进入 for 语句时，将执行一次 initialize 语句。每次执行循环体之前将计算 condition 的结果。如果 condition 为 true，则执行循环体。 每次执行循环体之后，在计算下一个迭代的 condition 之前，将执行 increment 语句。 instanceof 实例 instanceof 关键字用来确定对象所属的类。 switch 观察 switch 语句用于基于某个表达式选择执行多个代码块中的某一个。 switch 条件的计算结果必须等于 byte、char、short 或 int。 case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 case 返回观察里的结果 case 用来标记 switch 语句中的每个分支。 case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 default 默认 default 关键字用来标记 switch 语句中的默认分支。 default 块没有隐式结束点。break 语句通常在每个 case 或 default 块的末尾使用，以便在完成块时退出 switch 语句。 如果没有 default 语句，其参数与任何 case 块都不匹配的 switch 语句将不执行任何操作。 4、错误处理 try 捕获异常 try 关键字用于包含可能引发异常的语句块。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 catch 处理异常 catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块。 开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 throw 抛出一个异常对象 throw 关键字用于引发异常。 throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。 throws 声明一个异常可能被抛出 throws 关键字可以应用于方法，以便指出方法引发了特定类型的异常。 throws 关键字将逗号分隔的 java.lang.Throwables 列表作为参数。 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。要在 try-catch 块中包含带 throws 子句的方法的调用，必须提供该方法的调用者。 finally 在异常处理机制当中，它的作用就像是人吃饭一样，必须得做的，不论有异常还是没有异常都要执行的代码就可以放到finally块当中去。finally块，必须要配合try块一起使用，不能单独使用，也不能直接和catch块一起使用。 finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。 finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。 5、包相关 import 引入 import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。 package 包 package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。例:java.lang.Object。如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。 6、基本类型 boolean 布尔型 boolean 是 Java 原始类型。boolean 变量的值可以是 true 或 false。 boolean 变量只能以 true 或 false 作为值。boolean 不能与数字类型相互转换。 包含 boolean 操作数的表达式只能包含 boolean 操作数。 Boolean 类是 boolean 原始类型的包装对象类。 byte 字节型 byte 是 Java 原始类型。byte 可存储在 [-128, 127] 范围以内的整数值。 Byte 类是 byte 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 char 字符型 char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 可以使用下列 char 常量： \\b - 空格, \\f - 换页, \\n - 换行, \\r - 回车, \\t - 水平制表符, ' - 单引号, &quot; - 双引号, \\ - 反斜杠, \\xxx - 采用 xxx 编码的 Latin-1 字符。\\x 和 \\xx 均为合法形式，但可能引起混淆。 \\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符。 Character 类包含一些可用来处理 char 变量的 static 方法，这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。 char 值没有符号。 double 双精度 double 是 Java 原始类型。double 变量可以存储双精度浮点值。 由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。 Java 浮点数值可代表无穷大和 NaN（非数值）。Double 包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 float 浮点 float 是 Java 原始类型。float 变量可以存储单精度浮点值。 使用此关键字时应遵循下列规则： Java 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 f 或 F，如 0.01f。 由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。 Java 浮点数值可代表无穷大和 NaN（非数值）。Float 包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 int 整型 int 是 Java 原始类型。int 变量可以存储 32 位的整数值。 Integer 类是 int 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 long 长整型 long 是 Java 原始类型。long 变量可以存储 64 位的带符号整数。 Long 类是 long 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 short 短整型 short 是 Java 原始类型。short 变量可以存储 16 位带符号的整数。 Short 类是 short 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 null 空 null 是 Java 的保留字，表示无值。 将 null 赋给非原始变量相当于释放该变量先前所引用的对象。 不能将 null 赋给原始类型（byte、short、int、long、char、float、double、boolean）变量。 true 真 true 关键字表示 boolean 变量的两个合法值中的一个。 false 假 false 关键字代表 boolean 变量的两个合法值之一。 7、变量引用 super 父类,超类 super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。super.() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。 this 本类 this 关键字用于引用当前实例。当引用可能不明确时，可以使用 this 关键字来引用当前的实例。 void 无返回值 void 关键字表示 null 类型。void 可以用作方法的返回类型，以指示该方法不返回值。 8、保留字 正确识别java语言的关键字（keyword）和保留字（reserved word）是十分重要的。Java的关键字对java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等。保留字是为java预留的关键字，他们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。识别java语言的关键字，不要和其他语言如c/c++的关键字混淆。const和goto是java的保留字。 所有的关键字都是小写 goto 跳转 goto 保留关键字，但无任何作用。结构化程序设计完全不需要 goto 语句即可完成各种流程，而 goto 语句的使用往往会使程序的可读性降低，所以 Java 不允许 goto 跳转。 const 静态 const 保留字，是一个类型修饰符，使用const声明的对象不能更新。与final某些类似。","link":"/2022/07/24/2016-04-10-Java-key/"},{"title":"凸包算法剖析","text":"前言前天，刚考完证券，以前帮别人搞金融时候的一些问题也算有了点自己的答案。当然，今天不是说这个。正好也是前几天，好基友跑来问我凸包算法，一时就楞住了，好像还真没有搞过计算机几何方面的。于是赶忙就Google了下，把凸包的几种算法都搞了个清楚。所以，今天就来讲讲凸包算法吧。 何为凸包首先，我们的搞清楚，什么叫做凸包。假设平面上有p0~p12共13个点，过某些点作一个最小多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。如图： 换种说法便是：令S是平面上的一个点集，封闭S中所有顶点的最小凸多边形，称为S的凸包。 然后，什么是凸包问题？ 我们把这些点放在二维坐标系里面，那么每个点都能用 (x,y) 来表示。 现给出点的数目为13，已知各个点的坐标，求构成凸包的点。 解一：穷举法（暴力法）时间复杂度：O(n³）。 思路：两点确定一条直线，如果剩余的其它点都在这条直线的同一侧，则这两个点是凸包上的点，否则就不是。 步骤： 1、将点集里面的所有点两两配对，组成 n(n-1)/2 条直线。 2、对于每条直线，再检查剩余的 (n-2) 个点是否在直线的同一侧。 如何判断一个点 p3 是在直线 p1p2 的左边还是右边呢？（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)） 当上式结果为正时，p3在直线 p1p2 的左侧；当结果为负时，p3在直线 p1p2 的右边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.cyw.algorithms;import java.util.*;public class ConvexHullExhaustive { public static class Line {//线 Point p1, p2; Line(Point p1, Point p2) { this.p1 = p1; this.p2 = p2; } } public static class Point{//点 int x; int y; } List&lt;Point&gt; pts = null;//点集 List&lt;Line&gt; lines = new ArrayList&lt;Line&gt;();//点集pts的凸包 public void setPointList(List&lt;Point&gt; pts) { this.pts = pts; } public List&lt;Line&gt; eval() { lines.clear(); if (pts == null) { return lines; } int n = pts.size(); int a, b, c, cc, l, r; for (int i = 0; i &lt; n; i++) { for (int j = i+1; j &lt; n; j++) {//穷举点集中任意两点组成的直线ax+by=c a = pts.get(j).y - pts.get(i).y;// b = pts.get(i).x - pts.get(j).x; c = pts.get(i).x * pts.get(j).y -pts.get(i).y * pts.get(j).x; l = r = 0; int k; for (k = 0; k &lt; n; k++) {//穷举点集中的每一点 cc = a * pts.get(k).x + b * pts.get(k).y; if (cc &gt; c) l++; else if (cc &lt; c) r++; if (l * r != 0) break;//直线两侧都有点, } if (k == n) {//凸包中添加一条边 lines.add(new Line(pts.get(i), pts.get(j))); } } } return lines; }} 解二：分治法时间复杂度：O(n㏒n)。 思路：应用分治法思想，把一个大问题分成几个结构相同的子问题，把子问题再分成几个更小的子问题。然后我们就能用递归的方法，分别求这些子问题的解。最后把每个子问题的解“组装”成原来大问题的解。 步骤： 1、把所有的点都放在二维坐标系里面，在横坐标方向上按照大小排序。那么横坐标最小和最大的两个点 P1 和 Pn 一定是凸包上的点。直线 P1Pn 把点集分成了两部分，即 X 轴上面和下面两部分，分别叫做上包和下包。 2、对上包，找到一个距离直线 P1Pn 最远的点，即下图中的点 Pmax 。 3、作直线 P1Pmax 、PnPmax，把直线 P1Pmax 左侧的点当成是上包，把直线 PnPmax 右侧的点也当成是上包。显然直线段P1Pmax与直线段PmaxPn把点集分为三个集合。由凸包的性质可控制，P1PmaxPn三点围成的三角形中的点不可能作为凸包的顶点，所以只需考虑直线P1Pmax左边的点以及直线PmaxPn右边的点。 4、重复步骤 2、3。递归求解得到凸多边形的边。 5、对下包也作类似操作。 6、合并这些边即得所求的凸包。 然而怎么求距离某直线最远的点呢？我们还是用到解一中的公式： 设有一个点 P3 和直线 P1P2 （坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)），对上式的结果取绝对值，绝对值越大，则距离直线越远。 注意：在步骤一，如果横坐标最小的点不止一个，那么这几个点都是凸包上的点，此时上包和下包的划分就有点不同了，需要注意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.cyw.algorithms;import java.util.*; public class ConvexHullDivideAndConquer { /* * 分治法求凸包 */// public class QuickTuBao { private List&lt;Point&gt; pts = null;//给出的点集S private List&lt;Line&gt; lines = new ArrayList&lt;Line&gt;();//点集pts的凸包，多边形上的边以及边上的顶点 public void setPointList(List&lt;Point&gt; pts) { this.pts = pts; } public ConvexHullDivideAndConquer(List&lt;Point&gt; pts){ this.pts=pts; } public ConvexHullDivideAndConquer(){ } //求凸包，结果存入lines中 public List&lt;Line&gt; eval() { lines.clear(); if (pts == null || pts.isEmpty()) { return lines; } List&lt;Point&gt; ptsLeft = new ArrayList&lt;Point&gt;();//左凸包中的点 List&lt;Point&gt; ptsRight = new ArrayList&lt;Point&gt;();//右凸包中的点 //按x坐标对pts排序，从小到大 Collections.sort(pts, new Comparator&lt;Point&gt;() { public int compare(Point p1, Point p2) { if(p1.x-p2.x&gt;0) return 1; if(p1.x-p2.x&lt;0) return -1; return 0; } }); Point p1 = pts.get(0);//最左边的点 //最右边的点,用直线p1p2将原凸包分成两个小凸包 Point p2 = pts.get(pts.size()-1); Point p3 = null; double area = 0; for (int i = 1; i &lt; pts.size()-1; i++) {//穷举所有的点, p3 = pts.get(i); //求此三点所成三角形的有向面积。对点进行分类，是这两点直线的左边还是右边 area = getArea(p1, p2, p3); if (area &gt; 0) { ptsLeft.add(p3);//p3属于左 } else if (area &lt; 0) { ptsRight.add(p3);//p3属于右 } } d(p1, p2, ptsLeft);//分别求解 d(p2, p1, ptsRight); return lines; } //递归 private void d(Point p1, Point p2, List&lt;Point&gt; s) { //s集合为空 if (s.isEmpty()) { lines.add(new Line(p1, p2)); return; } //s集合不为空，寻找Pmax double area = 0; double maxArea = 0; Point pMax = null; for (int i = 0; i &lt; s.size(); i++) { area = getArea(p1, p2, s.get(i));//最大面积对应的点就是Pmax if (area &gt; maxArea) { pMax = s.get(i); maxArea = area; } } //找出位于(p1, pMax)直线左边的点集s1 //找出位于(pMax, p2)直线左边的点集s2 List&lt;Point&gt; s1 = new ArrayList&lt;Point&gt;(); List&lt;Point&gt; s2 = new ArrayList&lt;Point&gt;(); Point p3 = null; for (int i = 0; i &lt; s.size(); i++) { p3 = s.get(i); if (getArea(p1, pMax, p3) &gt; 0) { s1.add(p3); } else if (getArea(pMax, p2, p3) &gt; 0) { s2.add(p3); } } //递归 d(p1, pMax, s1); d(pMax, p2, s2); } // 三角形的面积等于返回值绝对值的二分之一 // 当且仅当点p3位于直线(p1, p2)左侧时，表达式的符号为正 private double getArea(Point p1, Point p2, Point p3) { return p1.x * p2.y + p3.x * p1.y + p2.x * p3.y - p3.x * p2.y - p2.x * p1.y - p1.x * p3.y; }// } public static class Line {//线 Point p1, p2; Line(Point p1, Point p2) { this.p1 = p1; this.p2 = p2; } public double getLength() { double dx = Math.abs(p1.x - p2.x); double dy = Math.abs(p1.y - p2.y); return Math.sqrt(dx * dx + dy * dy); } } public static class Point{//点 double x; double y; public Point(double x,double y){ this.x=x; this.y=y; } } public static void main(String [] args){ ConvexHullDivideAndConquer ch = new ConvexHullDivideAndConquer(); List&lt;Point&gt; pts = new ArrayList&lt;Point&gt;(); pts.add(new Point(0,1)); pts.add(new Point(0,3)); pts.add(new Point(1,2)); pts.add(new Point(2,2)); pts.add(new Point(3,1)); pts.add(new Point(3,3)); List&lt;Line&gt; result = new ArrayList&lt;Line&gt;(); ch.setPointList(pts); result = ch.eval(); for(Line l : result){ System.out.println(&quot;(&quot;+l.p1.x+&quot;,&quot;+l.p1.y+&quot;)(&quot;+l.p2.x+&quot;,&quot;+l.p2.y+&quot;)&quot;); } }} 解三：Jarvis步进法时间复杂度：O(nH)。（其中 n 是点的总个数，H 是凸包上的点的个数） 思路： 1、纵坐标最小的那个点一定是凸包上的点，例如图上的 P0。 2、从 P0 开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。 3、怎么找下一个点呢？利用夹角。假设现在已经找到 {P0，P1，P2} 了，要找下一个点：剩下的点分别和 P2 组成向量，设这个向量与向量P1P2的夹角为 β 。当 β 最小时就是所要求的下一个点了，此处为 P3 。 注意： 1、找第二个点 P1 时，因为已经找到的只有 P0 一个点，所以向量只能和水平线作夹角 α，当 α 最小时求得第二个点。 2、共线情况：如果直线 P2P3 上还有一个点 P4，即三个点共线，此时由向量P2P3 和向量P2P4 产生的两个 β 是相同的。我们应该把 P3、P4 都当做凸包上的点，并且把距离 P2 最远的那个点（即图中的P4）作为最后搜索到的点，继续找它的下一个连接点。 解四：Graham扫描法时间复杂度：O(n㏒n) 思路：Graham扫描的思想和Jarris步进法类似，也是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，但它不是利用夹角，而是利用了左转判定。 左转判定 ，这一思想在凸包算法里十分的重要，是如何判断两个向量 p1=(x1,y1) 和 p2=(x2,y2) 是否左转的一个判定方法。非常简单的，只需判断 x1y2-x2y1 的正负值即可，为正说明 p1 到 p2 为左转。即是说，它可以用来判断一个向量到另一个向量是逆时针转还是顺时针转。 步骤： 1、把所有点放在二维坐标系中，则纵坐标最小的点一定是凸包上的点，如图中的P0。 2、把所有点的坐标平移一下，使 P0 作为原点，如上图。 3、计算各个点相对于 P0 的幅角 α ，按从小到大的顺序对各个点排序。当 α 同时，距离 P0 比较近的排在前面。例如上图得到的结果为P1，P2，P3，P4，P5，P6，P7，P8。我们由几何知识可以知道，结果中第一个点 P1 和最后一个点 P8 一定是凸包上的点。 以上，我们已经知道了凸包上的第一个点P0和第二个点P1，我们把它们放在栈里面。现在从步骤3求得的那个结果里，把 P1 后面的那个点拿出来做当前点，即 P2 。接下来开始找第三个点： 4、连接P0和栈顶的那个点，得到直线 L 。看当前点是在直线 L 的右边还是左边。如果在直线的右边就执行步骤5；如果在直线上，或者在直线的左边就执行步骤6。 5、如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤4。 6、当前点是凸包上的点，把它压入栈，执行步骤7。 7、检查当前的点 P2 是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把 P2 后面那个点做当前点，返回步骤4。 最后，栈中的元素就是凸包上的点了。以下为用Graham扫描法动态求解的过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.util.Scanner;public class ConvexHullWithGraham { Point[] ch; //点集p的凸包 Point[] p ; //给出的点集 int n; int l; int len=0; public ConvexHullWithGraham(Point[] p,int n,int l){ this.p=p; this.n=n; this.l=l; ch= new Point[n]; } //小于0,说明向量p0p1的极角大于p0p2的极角 public double multiply(Point p1, Point p2, Point p0) { return ((p1.getX() - p0.getX()) * (p2.getY() - p0.getY()) - (p2.getX()- p0.getX()) * (p1.getY()- p0.getY())); } //求距离 public double distance(Point p1, Point p2) { return (Math.sqrt((p1.getX() - p2.getX()) * (p1.getX() - p2.getX()) + (p1.getY() - p2.getY()) * (p1.getY() - p2.getY()))); } public void answer(){ double sum = 0; for (int i = 0; i &lt; len - 1; i++) { sum += distance(ch[i], ch[i + 1]); } if (len &gt; 1) { sum += distance(ch[len - 1], ch[0]); } sum += 2 * l * Math.PI; System.out.println(Math.round(sum)); } public int Graham_scan() { int k = 0, top = 2; Point tmp; //找到最下且偏左的那个点 for (int i = 1; i &lt; n; i++) if ((p[i].getY() &lt; p[k].getY()) || ((p[i].getY() == p[k].getY()) &amp;&amp; (p[i].getX() &lt; p[k].getX()))) k = i; //将这个点指定为pts[0],交换pts[0]与pts[k] tmp = p[0]; p[0] = p[k]; p[k] = tmp; //按极角从小到大,距离偏短进行排序 for (int i = 1; i &lt; n - 1; i++) { k = i; for (int j = i + 1; j &lt; n; j++) if ((multiply(p[j], p[k], p[0]) &gt; 0) || ((multiply(p[j], p[k], p[0]) == 0) &amp;&amp; (distance( p[0], p[j]) &lt; distance( p[0], p[k])))) k = j; //k保存极角最小的那个点,或者相同距离原点最近 tmp = p[i]; p[i] = p[k]; p[k] = tmp; } //前三个点先入栈 ch[0] = p[0]; ch[1] = p[1]; ch[2] = p[2]; //判断与其余所有点的关系 for (int i = 3; i &lt; n; i++) { //不满足向左转的关系,栈顶元素出栈 while (top &gt; 0 &amp;&amp; multiply(p[i], ch[top], ch[top - 1]) &gt;= 0) top--; //当前点与栈内所有点满足向左关系,因此入栈. ch[++top] = p[i]; } len=top+1; return len; } /**样例: Sample Input 9 100 200 400 300 400 300 300 400 300 400 400 500 400 500 200 350 200 200 200 Sample Output 1628 */ public static void main(String[] args) { Scanner in=new Scanner(System.in); int n = in.nextInt(); int l = in.nextInt(); int x, y; Point[] p = new Point[n]; for (int i = 0; i &lt; n; i++) { x = in.nextInt(); y = in.nextInt(); p[i] = new Point(x, y); } ConvexHullWithGraham ma=new ConvexHullWithGraham(p,n,l); ma.Graham_scan(); ma.answer(); } } 解五：Melkman算法Melkman凸包算法继承Graham扫描法的主要思想，并更近一步地采用双端队列，动态地在队列两头进行增删操作，维护“凸性”。 基本思想是：首先跟Graham扫描法一样，纵坐标最小的点作为基点，得到其他各点对该点的夹角，存储在栈中并排序。取最初的三点组合成为一个三角形。从一个三角形开始，对接下来的从栈中取出的每一个点，判断该点是否在该三角形内部，不在则添加该点，使得三角形不断地扩大范围，多边形的边数也在变化。获得到的点，序号可以连成一个闭环。另外是否在该多边形内部的判定是使用的左转判定，即是根据从双向表的两端开始，如果该点在在两边的左边（逆时针方向），则该点在多边形的内部。 具体的步骤是： 1、初始化。跟Graham一样，取一点，得到角度，然后排序各点。 2、接着 向双向表中依次装入P2,P0,P1,P2. 注意：这是一个收尾相连的三角形，三点不共线。 3、设置 双向表的左右指针分别是bot、top。该范围内是，不断扩大范围的凸包点多边形。 4、反复i++，即是按照顺序，判断Pi是否在该多边形的内部，直到不在内部，即是d[t-1]、d[t-2]、Pi(逆时针方向)不做左转，或者d[bot+1]、d[bot+2]、Pi不做左转。 5、循环以下步骤直至d[t-1]、d[t-2]、Pi做左转： t--; //退栈，判断是否在新的凸包内部。防止出现凹处将Pi从右压入d 6、循环以下步骤直至d[bot+1]、d[bot+2]、Pi做左转 b++; //退栈，判断是否在新的凸包内部。防止出现凹处将Pi从左压入d 注意：每次执行第5、6步时候，两端的都需要压入相同的数，使得凸包闭环。 这个算法可以在各点有序的前提下，每次获知一个点，就可以将先前的凸包改造成新的凸包。 因此，这是一个在线算法，有着其他算法无法比拟的优势。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248package com.cyw.algorithms;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class ConvexHullWithMelkman { private Point[] pointArray;//坐标数组 private final int N;//数据个数 private int D[]; // 数组索引，双向表 public ConvexHullWithMelkman(List&lt;Point&gt; pList) { this.pointArray = new Point[pList.size()]; N = pList.size(); int k = 0; for (Point p : pList) { pointArray[k++] = p; } D = new int[2 * N]; } /** * 求凸包点 * * @return 所求凸包点 */ public Point[] getTubaoPoint() { // 获得最小的Y，作为P0点 float minY = pointArray[0].getY(); int j = 0; for (int i = 1; i &lt; N; i++) { if (pointArray[i].getY() &lt; minY) { minY = pointArray[i].getY(); j = i; } } //交换内容 swap(0, j); // 计算除第一顶点外的其余顶点到第一点的线段与x轴的夹角 for (int i = 1; i &lt; N; i++) { pointArray[i].setArCos(angle(i)); } quickSort(1, N - 1); // 根据所得到的角度进行快速排序 int bot = N - 1; int top = N; D[top++] = 0; D[top++] = 1; int i; for (i = 2; i &lt; N; i++) {// 寻找第三个点 要保证3个点不共线！！==0 代表共线 if (isLeft(pointArray[D[top - 2]], pointArray[D[top - 1]], pointArray[i]) != 0) break; D[top - 1] = i; // 共线就更换顶点 } D[bot--] = i; D[top++] = i; // i是第三个点 不共线！！// 最初的一次 int t; if (isLeft(pointArray[D[N]], pointArray[D[N + 1]], pointArray[D[N + 2]]) &lt; 0) { // 此时队列中有3个点，要保证3个点a,b,c是成逆时针的，不是就调换ab t = D[N]; D[N] = D[N + 1]; D[N + 1] = t; } //开始 for (i++; i &lt; N; i++) { // 如果成立就是i在凸包内，跳过 //top=n+3 bot=n-2// 此时top、bot没有改变 if (isLeft(pointArray[D[top - 2]], pointArray[D[top - 1]],pointArray[i]) &gt; 0 &amp;&amp; isLeft(pointArray[D[bot + 1]], pointArray[D[bot + 2]],pointArray[i]) &gt; 0) { continue; } //非左转 则退栈 while (isLeft(pointArray[D[top - 2]], pointArray[D[top - 1]], pointArray[i]) &lt;= 0) { top--; } D[top++] = i; //反向表非左转 则退栈 while (isLeft(pointArray[D[bot + 1]], pointArray[D[bot + 2]], pointArray[i]) &lt;= 0) { bot++; } D[bot--] = i; } // 凸包构造完成，D数组里bot+1至top-1内就是凸包的序列(头尾是同一点) Point[] resultPoints = new Point[top - bot - 1]; int index = 0; for (i = bot + 1; i &lt; top - 1; i++) { System.out.println(pointArray[D[i]].getX() + &quot;,&quot; + pointArray[D[i]].getY()); resultPoints[index++] = pointArray[D[i]]; } return resultPoints; } /** * 判断ba相对ao是不是左转 * * @return 大于0则左转 */ private float isLeft(Point o, Point a, Point b) { float aoX = a.getX() - o.getX(); float aoY = a.getY() - o.getY(); float baX = b.getX() - a.getX(); float baY = b.getY() - a.getY(); return aoX * baY - aoY * baX; } /** * 实现数组交换 * * @param i * @param j */ private void swap(int i, int j) { Point tempPoint = new Point(); tempPoint.setX(pointArray[j].getX()); tempPoint.setY(pointArray[j].getY()); tempPoint.setArCos(pointArray[j].getArCos()); pointArray[j].setX(pointArray[i].getX()); pointArray[j].setY(pointArray[i].getY()); pointArray[j].setArCos(pointArray[i].getArCos()); pointArray[i].setX(tempPoint.getX()); pointArray[i].setY(tempPoint.getY()); pointArray[i].setArCos(tempPoint.getArCos()); } /** * 快速排序 * * @param top * @param bot */ private void quickSort(int top, int bot) { int pos; if (top &lt; bot) { pos = loc(top, bot); quickSort(top, pos - 1); quickSort(pos + 1, bot); } } /** * 移动起点，左侧为小，右侧为大 * @param top * @param bot * @return 移动后的位置 */ private int loc(int top, int bot) { double x = pointArray[top].getArCos(); int j, k; j = top + 1; k = bot; while (true) {// while (j &lt; bot &amp;&amp; pointArray[j].getArCos() &lt; x) j++;// while (k &gt; top &amp;&amp; pointArray[k].getArCos() &gt; x) k--; if (j &gt;= k) break; swap(j, k); } swap(top, k); return k; } /** * 角度计算 * * @param i 指针 * @return */ private double angle(int i) { double j, k, m, h; j = pointArray[i].getX() - pointArray[0].getX(); k = pointArray[i].getY() - pointArray[0].getY(); m = Math.sqrt(j * j + k * k); // 得到顶点i 到第一顶点的线段长度 if (k &lt; 0) j = (-1) * Math.abs(j); h = Math.acos(j / m); // 得到该线段与x轴的角度 return h; } /**data.txt:0 10 41 32 23 13 4 */ public static void main(String args[]) { // File file = new File(&quot;G:/yl.txt&quot;); File file = new File(&quot;D:/data.txt&quot;); BufferedReader br = null; try { br = new BufferedReader(new FileReader(file)); } catch (FileNotFoundException e) { e.printStackTrace(); } List&lt;Point&gt; pointList = new ArrayList&lt;Point&gt;(); String str = null; try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } while (str != null) { String[] s = str.split(&quot;\\\\t&quot;, 2); float x = Float.parseFloat(s[0].trim()); float y = Float.parseFloat(s[1].trim()); Point p = new Point(); p.setX(x); p.setY(y); // System.out.println(&quot;文件数据：&quot; + x + &quot;, &quot; + y); pointList.add(p); try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(&quot;数据个数：&quot; + pointList.size()); ConvexHullWithMelkman m = new ConvexHullWithMelkman(pointList); m.getTubaoPoint(); }} 以上几种算法的参考代码，我已经UP到了我的GItHub上面了，分别对应的是： 可以点击图片，到GitHub上面按需下载。","link":"/2022/07/24/2016-05-23-ConvexHull/"},{"title":"","text":"数据_陈越威_中南大学_18175139250 div, table, td, pre, input { margin: 0; padding: 0; } pre, textarea { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; } .border_box { box-sizing: border-box; -ms-box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } .row_layout .resume { margin: 0 auto; } .row_layout .resume .photo_table { border-collapse: separate; border-spacing: 0; table-layout: fixed; width: 100%; } .row_layout .resume .photo_table td { text-align: left; vertical-align: top; } .row_layout .resume .photo_table td img { border: 0; display: block; } .SimSun { font-family: SimSun, 宋体, 华文宋体; } .SimHei { font-family: SimHei, 黑体, Hei, 华文细黑, 华文黑体; } .SimKai { font-family: SimKai, 楷体, 楷体_GB2312, Kai, 华文楷体; } .SimFang { font-family: SimFang, 仿宋, 仿宋_GB2312, 华文仿宋; } .Arial { font-family: Arial; } .Times { font-family: Times New Roman; } .Tahoma { font-family: Tahoma; } .Verdana { font-family: Verdana; } .row_layout .resume { border: 1px solid #ccc; -webkit-box-shadow: 0 1px 10px rgba(0,0,0,0.5); -moz-box-shadow: 0 1px 10px rgba(0,0,0,0.5); box-shadow: 0 1px 10px rgba(0,0,0,0.5); } .row_layout .resume .section, .row_layout .resume .row { position: relative; } .row_layout .resume .row table { border-collapse: separate; border-spacing: 0; table-layout: fixed; width: 100%; } .row_layout .resume .row .cell pre { display: block; position: relative; line-height: 0; font-size: 0; } @-moz-document url-prefix() { .row_layout .resume .row table { table-layout: auto; } .row_layout .resume .row table td { max-width: 0; } } yalechen (+86) 181-7513-9250 yalechen@163.com Wechat: cyw20130609 Seeking for a data analysis engineer position EDUCATION Central South University Sep.2013-Jul.2017.07 Bachelor in Automation Professional SKILLS Computer Language: Java, R, Python Data Analysis Software: Hadoop, Matlab, R Version management tools: SVN, GitHub Algorithm: Machine Learning Algorithm Operating Systems: Linux, Windows PROJECT EXPERIENCES OriStone Programming Language 2015-2016 Principal: Originally develope. OriStone is a scripting language based on Java, which is object-oriented, and has its own VM. Base on BNF paradigm, and regular expression parsing. The language compiler, interpreter, grammatical structure and VM, have already been constructed. Entrepreneurial team of FindThings App 2014-2016 CTO and Android development engineer To meet the demand for skills and matching inside the College, the team, an intermediary platforms, including Android App and website, was established. The project won the second prize of the Innovation, Entrepreneurship and Creativity Contest. I am responsible for the speech, looking for investment. Use technology development frameworks Volley. Rescue Simulation Group of RoboCup Competition 2015-2016 Core member Based on photoelectric sensor and MCU, automatically patrol movement and the intelligent car on a particular task Write operation algorithm of agents. Use KNN algorithm for partition, A * algorithm for searching path and so on. Won the second prize of RoboCup in the world, and won the first prize in the national competition of RoboCup. INTERN EXPERIENCE Qutke Ltd. in Beijing Dec.2015-Feb.2016 R Programming Language intern Optimized code about the Internet banking, and wrote the blog about how to use the API. Pipa Planet Ltd. in Changsha Aug.2015-Sep.2019 All Stack Engineer Responsible for Web Development.Use the technical framework of bootsrap. BLOG: cyw3.github.io/yalechen HOBBIES Sing songs, traveling, skating, Eason,the book of Three Body, AI.","link":"/2022/07/24/2016-03-15-YalesonChan/"},{"title":"Java字节码总结","text":"目录 1. 概述 2. 举个栗子 3. Class文件结构 4. 指令 1) 字节码与数据类型 2) 加载和存储指令 3) 运算指令 4) 类型转换指令 5) 对象创建与访问指令 6) 操作数栈管理指令 7) 控制转移指令 8) 方法调用和返回指令 9) 异常处理指令 10) 同步指令 5. 再看几个栗子 例1 例2 例3 1. 概述学过Java的都知道，Java从一开始就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关性那就是语言无关性。实现语言无关性，那么Java体系中的class文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨平台的角度去设计的。 Java代码要想执行，需要先被编译成Class文件，即使Java字节码文件，然后才能够在JVM上执行。 那么现在我们简单的了解下Java字节码究竟是什么。这种类汇编的指令有是如何在JVM上面执行的呢？ 在Class文件中，Java方法里的方法体，也就是代表着一个Java源码程序中程序的部分存储在方法表集合的Code属性中。存储在Code属性中的是字节码，也就是编译后的程序。Java虚拟机的指令由两部分组成，首先是一个字节长度、代表某种含义的数字（即操作码），在操作码后面跟着零个或多个代表这个操作所需的参数（即操作数）。由于Java虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令不包含操作数，只有一个操作码。 操作码的长度只有一个字节，这就限制了操作码的个数不超过256个。同时，Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构。比如，如果要将一个两个字节长的无符号整数使用两个无符号字节存储起来分别是byte1和byte2，那么就需要这样构造出原始的无符号整数： (byte1&lt;&lt;8) | byte2 操作数的数量以及长度，取决于操作码，若一个操作数长度超过了一个字节，将会以Big-Endian顺序存储(高位在前字节码)。 这样会在某种程度上导致执行字节码时损失一些性能。但这样做也有好处，那就是由于不需要对齐，省去了中间的填充与间隔符号；用一个字节来表示操作码，也是为了获得短小的编译代码。这样就尽可能的减少了编译后的代码的长度，非常适合网络传输。 如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面的伪代码作为基本的执行模型来理解： 12345678do{ 自动计算PC寄存器的值加1; 根据PC寄存器的指示位置，从字节码流中取出操作码; if(字节码存在操作数) 从字节码流中取出操作数; 执行操作码所定义的操作; }while(字节码长度&gt;0); 2. 举个栗子可能大家现在有点不明觉厉哦，那么咱们先上代码，看看是个什么情况。 首先是一个简单的在控制台打印“Hello”的Java代码，如下： 1234567public class SimpleClass { public void sayHello() { System.out.println(&quot;Hello&quot;); }} 然后我们使用javac SimpleClass.java命令，编译该Java代码，生成相应的Class文件。然后，继续在终端中使用javap -verbose SimpleClass，打印Class文件中的内容。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Classfile /C:/Users/yalechen/Desktop/JVM/Java Byte Code/samples/SimpleClass.class Last modified 2016-8-16; size 400 bytes MD5 checksum 92d47034320261dac69592f3c3e33c2e Compiled from &quot;SimpleClass.java&quot;public class SimpleClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#14 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #15.#16 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #17 // Hello #4 = Methodref #18.#19 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #20 // SimpleClass #6 = Class #21 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 sayHello #12 = Utf8 SourceFile #13 = Utf8 SimpleClass.java #14 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #15 = Class #22 // java/lang/System #16 = NameAndType #23:#24 // out:Ljava/io/PrintStream; #17 = Utf8 Hello #18 = Class #25 // java/io/PrintStream #19 = NameAndType #26:#27 // println:(Ljava/lang/String;)V #20 = Utf8 SimpleClass #21 = Utf8 java/lang/Object #22 = Utf8 java/lang/System #23 = Utf8 out #24 = Utf8 Ljava/io/PrintStream; #25 = Utf8 java/io/PrintStream #26 = Utf8 println #27 = Utf8 (Ljava/lang/String;)V{ public SimpleClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public void sayHello(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 6: 0 line 7: 8}SourceFile: &quot;SimpleClass.java&quot; 我们从上往下依次解析。 首先是该Class文件的整体信息介绍，包括文件所在路径、最近修改时间、文件大小、MD5校验值、从哪个Java编译而来。接下来才是正文。 我们一步一步来： 1） 该类的声明 2） Minor version，表示Class文件的次版本号。Major version，表示Class文件的主版本号。major_version和minor_version主要用来表示当前的虚拟机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的 Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。 3） Flags，是该类的一些标识，包括访问权限（public、private、protected），父类、实现的接口等等。 4） Constant pool，常量池。以下的一些都是定义的常量。这个算是Java代码编译上的一种优化，把一些引用明确的变量、方法、类等，转换成直接引用。 在能够唯一确定方法的直接引用的时候，虚拟机会将常量表里的符号引用转换为直接引用。但是如果方法是动态绑定的，也就是说在编译期我们并不知道使用哪个方法（或者叫不知道使用方法的哪个版本），那么这个时候就需要在运行时才能确定哪个版本的方法将被调用，这个时候才能将符号引用转换为直接引用。这个问题提到的多个版本的方法在java中的重载和多态重写问题息息相关。 具体的定义，比如： #1 = Methodref #6.#14 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #1是定义的引用的别称； Methodref是该引用的具体类别，还有好几种不同的类别，之后会提及； #6.#14是具体的引用名称，不过此时的引用名称也是有下面定义的引用别称来表示的。后面的双斜杠注释表示对引用的解释。 5） 花括号中的便是SimpleClasss类的内容了。其中是一个一个的方法定义。 6） public SimpleClass();这个是构造方法的声明。简直就是Java代码有没有。 7） descriptor: ()V描述。()V，看到括号里面没有参数，V便是Void，所以这是个无参无返回值的方法。 8） flags的含义跟跟上面提及的一样。 9） code属性，表示的是方法的具体内容。 10）stack、locals以及args_size，读入栈深度建立符合要求的操作数栈，读入局部变量大小建立符合要求的局部变量表，根据参数个数向局部变量表中依序加入参数（第一个参数是引用当前对象的this，所以空参数列表的参数数也是1） 11）LineNumberTable，是指每一个java字节码指令对应java代码文件中的第几行，以方便定位。 12）同理，sayHello方法也是如此道理。 13）SourceFile，这是源代码。 不知大家看懂了多少，先凑合着来，慢慢理清头绪。 3. Class文件结构首先需要明确如下几点： 1）Class文件是由8个字节为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8个字节的数据，将按照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为 PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。 2） Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。 明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据： 在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用 constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语言那里，一个int型的数组，每个int长度都一样。明确了这一点以后，我们在回过头来看看上图中每一项都具体代表了什么含义。 1）u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE. 2）u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。 3）u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的 Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。 4）u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器长生的各种字面量以及符号引用，只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。 5）cp_info 表示常量池，这里面就存在了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在The Java Virtual Machine Specification Java SE 7 Edition 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。 下面分别简单描述一下具体细节等到后面的实例中我们再细化。 1234567891011121314151617181920212223CONSTANT_Utf8_info tag标志位为1, UTF-8编码的字符串CONSTANT_Integer_info tag标志位为3，整形字面量CONSTANT_Float_info tag标志位为4，浮点型字面量CONSTANT_Long_info tag标志位为5，长整形字面量CONSTANT_Double_info tag标志位为6，双精度字面量CONSTANT_Class_info tag标志位为7，类或接口的符号引用CONSTANT_String_info tag标志位为8，字符串类型的字面量CONSTANT_Fieldref_info tag标志位为9, 字段的符号引用CONSTANT_Methodref_info tag标志位为10，类中方法的符号引用CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用 可参考下图。 而这是在Java字节码中常出现的各种常量类型的字符描述符： 6）u2 access_flags 表示类或者接口的访问信息，具体如下图所示： 7）u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量 8）u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量 9）u2 interface_counts 表示接口的数量 10）u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量 11）u2 fields_count 表示类的实例变量和类变量的数量 12）field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示： 上图中access_flags表示字段的访问表示，比如字段是public,private，protect 等，name_index表示字段名称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为 CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。 13）u2 methods_count表示方法表的数量 14）method_info 表示方法表，方法表的具体结构如下图所示： 其中access_flags表示方法的访问表示，name_index表示名称的索引，descriptor_index表示方法的描述符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法表中就Code属性，表示方法的代码，而字段表中就没有Code属性。Code属性的结构如下图： attribute_name_index指向常量池中值为Code的常量； attribute_length表示Code属性表的长度（这里需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）； max_stack表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度，而max_locals代表了局部变量表的存储空间； max_locals的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如 byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用； code_length代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令； exception_table_length以及exception_table分别代表方法对应的异常信息； attributes_count和attribute_info分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。 15） attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点： 属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表 属性表的长度是不固定的，不同的属性，属性表的长度是不同的 16）LineNumberTable，用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性，如果通过-g:none的编译器参数来取消生成这项信息的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断点，接下来我们再看一下LineNumberTable的结构如下图所示： 其中attribute_name_index表示常量池的索引，attribute_length表示属性长度，而start_pc和 line_number分表表示字节码的行号和源代码的行号。 17）SourceFile，SourceFile的结构如下图所示： 其中attribute_length为属性的长度，sourcefile_index指向常量池中值为源代码文件名称的常量。 4. 指令以下是具体使用到的Java字节码指令集。 1) 字节码与数据类型在Java虚拟机的指令集中，大多数的指令都包含了操作所对应的数据类型信息。比如iload指令表示从局部变量表中加载int型数据到操作数栈中，而fload表示加载float类型的数据。不过，这两条指令再虚拟机的内部可能是由同一段代码来实现的，但在class文件中必须有自己的操作码。 我们已经知道Java指令的长度只有一个字节，这就限制了指令集的大小。如果每个指令都像上面两个指令那样包含所有的数据类型，那么就有可能导致指令过多。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。比如，大多数指令没有支持整数类型byte、char和short，甚至没有指令支持boolean类型。 这些指令中都有特殊的字符来表示专门支持的类型：i代表int类型，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表Reference。 这里仅仅介绍一下指令的种类以及作用，并不会过多的介绍各个指令的含义以及使用，需要的话可以查看《Java虚拟机规范（Java SE 7版）》。 2) 加载和存储指令加载指令用于将局部变量表中的数据传送到操作数栈中，而存储指令用于将操作数栈中的结果传送到局部变量表中。这类指令包括如下几种： 将一个局部变量加载到操作栈，比如iload、iload、fload、fload、lload、lload、dload、dload、aload、aload； 将一个数值从操作数栈存储到局部变量表，比如istore、istore、lstore、lstore、fstore、fstore、dstore、dstore、astore、astore； 将一个常量加载到操作数栈，比如bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_ml、iconst_、lconst_、fconst_、dconst_； 扩充局部变量表的访问索引的指令：wide； 上面中带尖括号的指令实际是一组指令。比如iload，代表了iload_1、iload_2和iload_3。这几组指令是某个带操作数的指令（比如iload）的特殊形式，它们省略了操作数，不过操作数隐含在指令中。 3) 运算指令运算或算术指令用于对一个或两个操作数栈上的值进行某种特定的运算，并将结果存入栈顶。大体上可以分为两种，对整数进行运算的指令和对浮点数进行运算的指令。不过，由于没有支持byte、short、char和boolean的算术指令，对于这些数据的运算，会把它们转化为int类型进行运算。指令列出如下： 12345678910111213141516171819202122232425加法指令：iadd、ladd、fadd、dadd；减法指令：isub、lsub、fsub、dsub；乘法指令：imul、lmul、fmul、dmul；除法指令：idiv、ldiv、fdiv、ddiv；求余指令：irem、lrem、frem、drem；取反指令：ineg、lneg、fneg、dneg；位移指令：ishl、ishr、iushr、lshl、lshr、lushr；按位或指令：ior、lor；按位与指令：iand、land；按位异或指令：ixor、lxor；局部变量自增指令：iinc；比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp； 4) 类型转换指令类型转换指令用来将两种不同类型进行转换，这些转换操作一般用于实现代码中的显示类型转换操作，或者前面提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。 虚拟机直接支持宽化类型转换，即小范围类型向大范围类型的安全转换，不需要显示的转换指令。 但是处理窄化类型转换时，必须显示使用转换指令来完成，这些指令包括：i2b、i2c、i2s、l2i、f2l、d2i、d2l和d2f。这些指令可能会导致数值的精度丢失。 5) 对象创建与访问指令虽然类实例和数组都是对象，但是虚拟机创建类对象和数组的指令是不同的。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或数组元素，指令如下： 创建类实例的指令：new； 创建数组的指令：newarray、anewarray、multianewarray； 访问类字段和实例字段的指令：getfield、putfield、getstatic、putstatic； 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload； 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore； 取数组长度的指令：arraylength； 检查类实例类型的指令：instanceof、checkcast； 6) 操作数栈管理指令就像操作一个普通的栈一样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括： 将操作数栈的栈顶一个或两个元素出栈：pop、pop2； 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2； 将栈顶最顶端的两个数值互换：swap； 7) 控制转移指令控制转移指令可以让Java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行，可以理解为控制转移指令改变了PC寄存器的值。指令如下： 条件分支：ifeq、iflt、ifle、ifgt、ifge、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、、if_icmpge、if_acmpeq和if_acmpne； 复合条件分支：tableswitch、lookupswitch； 无条件分支：goto、goto_w、jsr、jsr_w、ret； 8) 方法调用和返回指令这里仅仅列出5条用于方法调用的指令： invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式； invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用； invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法； invokestatic指令用于调用类方法（static方法）； invokedynamic指令用于在运行时动态解析出调用点限定符索引用的方法，并执行方法，前面4条指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的； 方法调用指令与类型无关，但是方法返回指令是根据返回值的类型区分的，包括ireturn、lreturn、freturn、dreturn和areturn，另外还有一个return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。 9) 异常处理指令在Java程序中显式抛出异常的操作（throw语句）都是由athrow指令来实现的，除了用throw语句显式抛出异常外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。 而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来完成的，而是采用异常表来完成的。 10) 同步指令Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。 方法级的同步是隐式的，即不需要通过字节码指令来控制，它实现在方法调用和返回操作中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令就会去检查方法的ACC_SYNCHRONIZED访问标志是否被设置了，如果设置，执行线程就要求持有管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个方法在执行期间发生了异常，并在方法中无法处理此异常，那么这个同步方法所持有的管程将在异常抛出后自动释放。 同步一段指令集序列通常是由Java语言中的synchronized语句块表示的，Java虚拟机的指令集中有monitorenter和monitorexit指令来支持synchronized关键字的语义。正确实现synchronized关键字需要Javac编译器和Java虚拟机两者共同协作。编译器必须保证每个monitorenter指令都有对应的monitorexit指令。 5. 再看几个栗子例1Java源代码如下： 1234567891011public class TestDemo { public static int minus(int x){ return -x; } public static void main(String[] args) { int x = 5; int y = minus(x); }} Javap–verbose TestDemo之后，得到Java字节码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Classfile /C:/Users/yalechen/Desktop/JVM/Java Byte Code/samples/TestDemo/TestDemo.class Last modified 2016-8-16; size 342 bytes MD5 checksum 77ff8854473da6d63caf8a5347bb3434 Compiled from &quot;TestDemo.java&quot;public class TestDemo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Methodref #3.#16 // TestDemo.minus:(I)I #3 = Class #17 // TestDemo #4 = Class #18 // java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 minus #10 = Utf8 (I)I #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 TestDemo.java #15 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #16 = NameAndType #9:#10 // minus:(I)I #17 = Utf8 TestDemo #18 = Utf8 java/lang/Object{ public TestDemo(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V V表示Void，()表示无参数，冒号之前表示的是方法名 4: return LineNumberTable: line 3: 0 public static int minus(int); descriptor: (I)I //描述符描述的参数列表和返回类型.I表示int flags: ACC_PUBLIC, ACC_STATIC //访问权限 Code: stack=1, locals=1, args_size=1 0: iload_0 //将slot0压入栈顶，也就是传入的参数 1: ineg //将栈顶的值弹出取负后压回栈顶 2: ireturn LineNumberTable: line 5: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: //确定可以访问后进入Code属性表执行命令 stack=1, locals=3, args_size=1 //读入栈深度建立符合要求的操作数栈，读入局部变量大小建立符合要求的局部变量表，根据参数个数向局部变量表中依序加入参数（第一个参数是引用当前对象的this，所以空参数列表的参数数也是1） 0: iconst_5 //前面 0 表示标识。将整数5压入栈顶 1: istore_1 //将栈顶整数值存入局部变量表的slot1（slot0是参数this）到这为止，int x = 5; 2: iload_1 //将slot1压入栈顶 3: invokestatic #2 // Method minus:(I)I 调用静态累方法minus。二进制invokestatic方法用于调用静态方法，参数是根据常量池中已经转换为直接引用的常量，意即minus函数在方法区中的地址，找到这个地址调用函数，向其中加入的参数是栈顶的值 6: istore_2 //此时的栈顶元素是经过了 minus 方法处理过了的 7: return LineNumberTable: line 8: 0 line 9: 2 line 10: 7}SourceFile: &quot;TestDemo.java&quot; 例21234567891011121314151617181920212223242526272829//测试重载机制public class TestDemo1 { static class Human{ } static class Man extends Human{ } static class Woman extends Human{ } public void sayHello(Human human) { System.out.println(&quot;hello human&quot;); } public void sayHello(Man man) { System.out.println(&quot;hello man&quot;); } public void sayHello(Woman woman) { System.out.println(&quot;hello woman&quot;); } public static void main(String[] args) { TestDemo1 demo = new TestDemo1(); Human man = new Man(); Human woman = new Woman(); demo.sayHello(man); demo.sayHello(woman); }} Java字节码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151Classfile /C:/Users/yalechen/Desktop/JVM/Java Byte Code/samples/TestDemo/TestDemo1.class Last modified 2016-8-16; size 883 bytes MD5 checksum 5a1df45f23bd666f3c6c716e50265345 Compiled from &quot;TestDemo1.java&quot;public class TestDemo1 //重载 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #14.#32 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #33.#34 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #35 // hello human #4 = Methodref #36.#37 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = String #38 // hello man #6 = String #39 // hello woman #7 = Class #40 // TestDemo1 #8 = Methodref #7.#32 // TestDemo1.&quot;&lt;init&gt;&quot;:()V #9 = Class #41 // TestDemo1$Man #10 = Methodref #9.#32 // TestDemo1$Man.&quot;&lt;init&gt;&quot;:()V #11 = Class #42 // TestDemo1$Woman #12 = Methodref #11.#32 // TestDemo1$Woman.&quot;&lt;init&gt;&quot;:()V #13 = Methodref #7.#43 // TestDemo1.sayHello:(LTestDemo1$Human;)V #14 = Class #44 // java/lang/Object #15 = Utf8 Woman #16 = Utf8 InnerClasses #17 = Utf8 Man #18 = Class #45 // TestDemo1$Human #19 = Utf8 Human #20 = Utf8 &lt;init&gt; #21 = Utf8 ()V #22 = Utf8 Code #23 = Utf8 LineNumberTable #24 = Utf8 sayHello #25 = Utf8 (LTestDemo1$Human;)V #26 = Utf8 (LTestDemo1$Man;)V #27 = Utf8 (LTestDemo1$Woman;)V #28 = Utf8 main #29 = Utf8 ([Ljava/lang/String;)V #30 = Utf8 SourceFile #31 = Utf8 TestDemo1.java #32 = NameAndType #20:#21 // &quot;&lt;init&gt;&quot;:()V #33 = Class #46 // java/lang/System #34 = NameAndType #47:#48 // out:Ljava/io/PrintStream; #35 = Utf8 hello human #36 = Class #49 // java/io/PrintStream #37 = NameAndType #50:#51 // println:(Ljava/lang/String;)V #38 = Utf8 hello man #39 = Utf8 hello woman #40 = Utf8 TestDemo1 #41 = Utf8 TestDemo1$Man #42 = Utf8 TestDemo1$Woman #43 = NameAndType #24:#25 // sayHello:(LTestDemo1$Human;)V #44 = Utf8 java/lang/Object #45 = Utf8 TestDemo1$Human #46 = Utf8 java/lang/System #47 = Utf8 out #48 = Utf8 Ljava/io/PrintStream; #49 = Utf8 java/io/PrintStream #50 = Utf8 println #51 = Utf8 (Ljava/lang/String;)V{ public TestDemo1(); //构造方法 descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public void sayHello(TestDemo1$Human); descriptor: (LTestDemo1$Human;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello human 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 11: 0 line 12: 8 public void sayHello(TestDemo1$Man); descriptor: (LTestDemo1$Man;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #5 // String hello man 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 14: 0 line 15: 8 public void sayHello(TestDemo1$Woman); descriptor: (LTestDemo1$Woman;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #6 // String hello woman 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 17: 0 line 18: 8 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: new #7 // class TestDemo1 3: dup 4: invokespecial #8 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: new #9 // class TestDemo1$Man 11: dup 12: invokespecial #10 // Method TestDemo1$Man.&quot;&lt;init&gt;&quot;:()V 15: astore_2 16: new #11 // class TestDemo1$Woman 19: dup 20: invokespecial #12 // Method TestDemo1$Woman.&quot;&lt;init&gt;&quot;:()V 23: astore_3 24: aload_1 25: aload_2 26: invokevirtual #13 // Method sayHello:(LTestDemo1$Human;)V 29: aload_1 30: aload_3 31: invokevirtual #13 // Method sayHello:(LTestDemo1$Human;)V 34: return LineNumberTable: //与源代码中的各行代码进行相互匹配 line 20: 0 line 21: 8 line 22: 16 line 23: 24 line 24: 29 line 25: 34}SourceFile: &quot;TestDemo1.java&quot;InnerClasses: static #15= #11 of #7; //Woman=class TestDemo1$Woman of class TestDemo1 static #17= #9 of #7; //Man=class TestDemo1$Man of class TestDemo1 static #19= #18 of #7; //Human=class TestDemo1$Human of class TestDemo1 例3123456789101112131415161718192021222324252627/*重写*/public class TestDemo2 { static class Human{ public void sayHello() { System.out.println(&quot;hello human&quot;); } } static class Man extends Human{ public void sayHello() { System.out.println(&quot;hello man&quot;); } } static class Woman extends Human{ public void sayHello() { System.out.println(&quot;hello woman&quot;); } } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); }} Java字节码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Classfile /C:/Users/yalechen/Desktop/JVM/Java Byte Code/samples/TestDemo/TestDemo2.class Last modified 2016-8-16; size 464 bytes MD5 checksum 2183e6c960f34e773da47dac5f8d717a Compiled from &quot;TestDemo2.java&quot;public class TestDemo2 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #8.#22 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #23 // TestDemo2$Man #3 = Methodref #2.#22 // TestDemo2$Man.&quot;&lt;init&gt;&quot;:()V #4 = Class #24 // TestDemo2$Woman #5 = Methodref #4.#22 // TestDemo2$Woman.&quot;&lt;init&gt;&quot;:()V #6 = Methodref #12.#25 // TestDemo2$Human.sayHello:()V #7 = Class #26 // TestDemo2 #8 = Class #27 // java/lang/Object #9 = Utf8 Woman #10 = Utf8 InnerClasses #11 = Utf8 Man #12 = Class #28 // TestDemo2$Human #13 = Utf8 Human #14 = Utf8 &lt;init&gt; #15 = Utf8 ()V #16 = Utf8 Code #17 = Utf8 LineNumberTable #18 = Utf8 main #19 = Utf8 ([Ljava/lang/String;)V #20 = Utf8 SourceFile #21 = Utf8 TestDemo2.java #22 = NameAndType #14:#15 // &quot;&lt;init&gt;&quot;:()V #23 = Utf8 TestDemo2$Man #24 = Utf8 TestDemo2$Woman #25 = NameAndType #29:#15 // sayHello:()V #26 = Utf8 TestDemo2 #27 = Utf8 java/lang/Object #28 = Utf8 TestDemo2$Human #29 = Utf8 sayHello{ public TestDemo2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: new #2 // class TestDemo2$Man 3: dup 4: invokespecial #3 // Method TestDemo2$Man.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: new #4 // class TestDemo2$Woman 11: dup 12: invokespecial #5 // Method TestDemo2$Woman.&quot;&lt;init&gt;&quot;:()V 15: astore_2 16: aload_1 17: invokevirtual #6 // Method TestDemo2$Human.sayHello:()V 20: aload_2 21: invokevirtual #6 // Method TestDemo2$Human.sayHello:()V 24: return LineNumberTable: line 21: 0 line 22: 8 line 23: 16 line 24: 20 line 25: 24}SourceFile: &quot;TestDemo2.java&quot;InnerClasses: static #9= #4 of #7; //Woman=class TestDemo2$Woman of class TestDemo2 static #11= #2 of #7; //Man=class TestDemo2$Man of class TestDemo2 static #13= #12 of #7; //Human=class TestDemo2$Human of class TestDemo2 可以从例2和例3看出，无论是重载还是重写，都是二进制指令invokevirtual调用了sayHello方法来执行的。 在重载中，程序调用的是参数实际类型不同的方法，但是虚拟机最终分派了相同外观类型（静态类型）的方法，这说明在重载的过程中虚拟机在运行的时候是只看参数的外观类型（静态类型）的，而这个外观类型（静态类型）是在编译的时候就已经确定的，和虚拟机没有关系。这种依赖静态类型来做方法的分配叫做静态分派。 在重写中，程序调用的是不同实际类型的同名方法，虚拟机依据对象的实际类型去寻找是否有这个方法，如果有就执行，如果没有去父类里找，最终在实际类型里找到了这个方法，所以最终是在运行期动态分派了方法。在编译的时候我们可以看到字节码指示的方法都是一样的符号引用，但是运行期虚拟机能够根据实际类型去确定出真正需要的直接引用。这种依赖实际类型来做方法的分配叫做动态分派。得益于java虚拟机的动态分派会在分派前确定对象的实际类型，面向对象的多态性才能体现出来。","link":"/2022/07/24/2016-08-22-Java-Byte-Code/"}],"tags":[],"categories":[],"pages":[]}